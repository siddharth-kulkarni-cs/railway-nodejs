<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Random Animation Gallery</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:400,500,700&display=swap">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <script src="https://cdn.jsdelivr.net/npm/p5@1.7.0/lib/p5.js"></script>
  <style>
    :root {
      --primary-color: #4a6fa5;
      --secondary-color: #6e9887;
      --accent-color: #ffc107;
      --light-bg: #f8f9fa;
      --dark-text: #333;
    }
    
    body {
      font-family: 'Roboto', sans-serif;
      background-color: var(--light-bg);
      color: var(--dark-text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }
    
    .site-header {
      background-color: white;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      padding: 1rem 0;
      margin-bottom: 2rem;
    }
    
    .site-title {
      color: var(--primary-color);
      font-weight: 700;
      margin-bottom: 0;
    }
    
    .navbar-custom {
      background-color: white;
      padding: 0.5rem 1rem;
    }
    
    .navbar-custom .nav-link {
      color: var(--primary-color);
      font-weight: 500;
      margin: 0 0.5rem;
      transition: color 0.3s ease;
    }
    
    .navbar-custom .nav-link:hover {
      color: var(--secondary-color);
    }
    
    main {
      margin-bottom: 3rem;
    }
    
    .animation-container {
      margin-bottom: 2rem;
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 6px 15px rgba(0,0,0,0.1);
      transition: transform 0.3s ease;
    }
    
    .animation-container:hover {
      transform: translateY(-5px);
    }
    
    .control-panel {
      background-color: white;
      padding: 1.5rem;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.08);
      margin-bottom: 2rem;
    }
    
    .btn-animation {
      background-color: var(--primary-color);
      color: white;
      border: none;
      margin-right: 0.5rem;
      transition: background-color 0.3s;
    }
    
    .btn-animation:hover {
      background-color: #3a5a80;
    }
    
    #currentAnimation {
      font-weight: 600;
      color: var(--primary-color);
    }
    
    footer {
      background-color: white;
      padding: 1.5rem 0;
      margin-top: auto;
      box-shadow: 0 -2px 10px rgba(0,0,0,0.05);
    }
    
    canvas {
      display: block;
      margin: 0 auto;
    }
  </style>
</head>
<body>
  <header class="site-header">
    <div class="container">
      <nav class="navbar navbar-expand-lg navbar-custom">
        <a class="navbar-brand" href="/">
          <h1 class="site-title">Product Showcase</h1>
        </a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarNav">
          <ul class="navbar-nav ml-auto">
            <li class="nav-item">
              <a class="nav-link" href="/">Home</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="/#products">Products</a>
            </li>
            <li class="nav-item active">
              <a class="nav-link" href="/animations">Animations</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="/#about">About</a>
            </li>
          </ul>
        </div>
      </nav>
    </div>
  </header>
  
  <main class="container">
    <h2 class="text-center mb-4">
      <i class="fas fa-magic text-primary mr-2"></i>
      Animation Gallery
    </h2>
    
    <div class="control-panel">
      <div class="d-flex align-items-center justify-content-between mb-3">
        <h4 class="mb-0">Choose Animation</h4>
        <div>
          <span>Current: <span id="currentAnimation">Particles</span></span>
        </div>
      </div>
      <div>
        <button class="btn btn-animation" onclick="switchAnimation('particles')">Particles</button>
        <button class="btn btn-animation" onclick="switchAnimation('waves')">Waves</button>
        <button class="btn btn-animation" onclick="switchAnimation('flocking')">Flocking</button>
        <button class="btn btn-animation" onclick="switchAnimation('fireworks')">Fireworks</button>
        <button class="btn btn-animation" onclick="switchAnimation('bubbles')">Bubbles</button>
        <button class="btn btn-animation" onclick="switchAnimation('matrix')">Matrix</button>
        <button class="btn btn-animation" onclick="switchAnimation('starfield')">Starfield</button>
        <button class="btn btn-animation" onclick="switchAnimation('geometric')">Geometric</button>
        <button class="btn btn-animation" onclick="switchAnimation('flow')">Flow Field</button>
        <button class="btn btn-animation" onclick="switchAnimation('physics')">Physics</button>
        <button class="btn btn-animation" onclick="switchAnimation('audio')">Audio Viz</button>
        <button class="btn btn-animation" onclick="switchAnimation('neural')">Neural Net</button>
      </div>
    </div>
    
    <div class="animation-container" id="canvasContainer">
      <!-- P5.js canvas will be inserted here -->
    </div>
    
    <div class="card">
      <div class="card-body">
        <h4 class="card-title">About This Animation</h4>
        <p class="card-text" id="animationDescription">
          Interactive particle system that responds to your mouse movements. Move your cursor across the canvas to interact with the particles.
        </p>
      </div>
    </div>
  </main>
  
  <footer>
    <div class="container text-center">
      <span class="text-muted">Siddharth Kulkarni Â© 2025. All rights reserved.</span>
    </div>
  </footer>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>
  
  <script>
    // Animation state
    let currentAnimationType = 'particles';
    let p5Instance = null;
    
    // Function to switch between animations
    function switchAnimation(type) {
      currentAnimationType = type;
      document.getElementById('currentAnimation').textContent = type.charAt(0).toUpperCase() + type.slice(1);
      
      // Update description
      const descriptions = {
        particles: "Interactive particle system that responds to your mouse movements. Move your cursor across the canvas to interact with the particles.",
        waves: "Mesmerizing wave animation using sine waves with randomized colors. The waves flow across the screen creating beautiful patterns.",
        flocking: "Simulation of flocking behavior (boids algorithm) where entities follow simple rules to create complex behaviors.",
        fireworks: "Celebratory fireworks that burst into colorful particles. Click anywhere on the canvas to launch fireworks.",
        bubbles: "Colorful bubbles that float gently upward with a dreamy, underwater effect. Hover over bubbles to interact with them.",
        matrix: "Digital rain inspired by The Matrix movie. Characters stream down in a cyberpunk visual aesthetic.",
        starfield: "A mesmerizing journey through a 3D star field, creating the illusion of moving through space.",
        geometric: "Abstract geometric patterns that transform and evolve, creating a hypnotic visual experience.",
        flow: "Dynamic flow field where particles follow naturally curved paths. Move your mouse to create swirling vortexes and patterns.",
        physics: "Interactive physics playground with realistic gravity and collisions. Click to create objects and watch them interact.",
        audio: "Audio visualization that pulses with beat detection. Click anywhere to generate sound waves and see them visualized.",
        neural: "Artificial neural network simulation that learns to follow your movements. Train it by drawing patterns with your mouse."
      };
      
      document.getElementById('animationDescription').textContent = descriptions[type];
      
      // Remove previous sketch if exists
      if (p5Instance) {
        p5Instance.remove();
      }
      
      // Create new sketch
      p5Instance = new p5(sketch, 'canvasContainer');
    }
    
    // P5.js sketch function
    const sketch = function(p) {
      // Variables for different animations
      let particles = [];
      let boids = [];
      let fireworks = [];
      let bubbles = [];
      let symbols = [];
      let streams = [];
      let stars = [];
      let shapes = [];
      let flowField = [];
      let flowParticles = [];
      let physicsBodies = [];
      let audioWaves = [];
      let audioLevel = 0;
      let neurons = [];
      let connections = [];
      let trainingData = [];
      let gravity;
      let time = 0;
      
      p.setup = function() {
        const container = document.getElementById('canvasContainer');
        const canvas = p.createCanvas(container.offsetWidth, 400);
        p.colorMode(p.HSB, 255);
        
        // Initialize based on animation type
        if (currentAnimationType === 'particles') {
          // Initialize particles
          for (let i = 0; i < 100; i++) {
            particles.push(new Particle());
          }
        } else if (currentAnimationType === 'flocking') {
          // Initialize boids
          for (let i = 0; i < 50; i++) {
            boids.push(new Boid(p.random(p.width), p.random(p.height)));
          }
        } else if (currentAnimationType === 'fireworks') {
          // Initialize gravity for fireworks
          gravity = p.createVector(0, 0.2);
        } else if (currentAnimationType === 'bubbles') {
          // Initialize bubbles
          for (let i = 0; i < 40; i++) {
            bubbles.push(new Bubble());
          }
        } else if (currentAnimationType === 'matrix') {
          // Initialize matrix columns
          initMatrix();
        } else if (currentAnimationType === 'starfield') {
          // Initialize stars
          for (let i = 0; i < 800; i++) {
            stars.push(new Star());
          }
        } else if (currentAnimationType === 'geometric') {
          // Initialize geometric shapes
          initGeometric();
        } else if (currentAnimationType === 'flow') {
          // Initialize flow field
          initFlowField();
        } else if (currentAnimationType === 'physics') {
          // Initialize physics playground
          initPhysics();
        } else if (currentAnimationType === 'audio') {
          // Initialize audio visualization
          initAudio();
        } else if (currentAnimationType === 'neural') {
          // Initialize neural network
          initNeuralNetwork();
        }
      };
      
      p.draw = function() {
        if (currentAnimationType === 'particles') {
          drawParticles();
        } else if (currentAnimationType === 'waves') {
          drawWaves();
        } else if (currentAnimationType === 'flocking') {
          drawFlocking();
        } else if (currentAnimationType === 'fireworks') {
          drawFireworks();
        } else if (currentAnimationType === 'bubbles') {
          drawBubbles();
        } else if (currentAnimationType === 'matrix') {
          drawMatrix();
        } else if (currentAnimationType === 'starfield') {
          drawStarfield();
        } else if (currentAnimationType === 'geometric') {
          drawGeometric();
        } else if (currentAnimationType === 'flow') {
          drawFlowField();
        } else if (currentAnimationType === 'physics') {
          drawPhysics();
        } else if (currentAnimationType === 'audio') {
          drawAudio();
        } else if (currentAnimationType === 'neural') {
          drawNeuralNetwork();
        }
      };
      
      p.mousePressed = function() {
        if (currentAnimationType === 'fireworks' && 
            p.mouseX > 0 && p.mouseX < p.width && 
            p.mouseY > 0 && p.mouseY < p.height) {
          fireworks.push(new Firework(p.mouseX, p.height, p.mouseX, p.mouseY));
        } else if (currentAnimationType === 'physics' && 
            p.mouseX > 0 && p.mouseX < p.width && 
            p.mouseY > 0 && p.mouseY < p.height) {
          createPhysicsBody(p.mouseX, p.mouseY);
        } else if (currentAnimationType === 'audio' && 
            p.mouseX > 0 && p.mouseX < p.width && 
            p.mouseY > 0 && p.mouseY < p.height) {
          createAudioPulse(p.mouseX, p.mouseY);
        }
        
        // For neural network, start recording mouse trail when pressed
        if (currentAnimationType === 'neural' && 
            p.mouseX > 0 && p.mouseX < p.width && 
            p.mouseY > 0 && p.mouseY < p.height) {
          trainingData = [];
          trainingData.push({x: p.mouseX, y: p.mouseY});
        }
      };
      
      p.mouseDragged = function() {
        if (currentAnimationType === 'neural' && 
            p.mouseX > 0 && p.mouseX < p.width && 
            p.mouseY > 0 && p.mouseY < p.height) {
          trainingData.push({x: p.mouseX, y: p.mouseY});
        } else if (currentAnimationType === 'flow' && 
            p.mouseX > 0 && p.mouseX < p.width && 
            p.mouseY > 0 && p.mouseY < p.height) {
          // Create a vortex at the mouse position
          createVortex(p.mouseX, p.mouseY);
        }
      };
      
      p.mouseReleased = function() {
        if (currentAnimationType === 'neural' && trainingData.length > 5) {
          trainNeuralNetwork(trainingData);
        }
      };
      
      // Particles animation
      function drawParticles() {
        p.background(230, 50, 15);
        
        for (let i = 0; i < particles.length; i++) {
          let particle = particles[i];
          particle.move();
          particle.display();
          particle.checkEdges();
        }
      }
      
      class Particle {
        constructor() {
          this.position = p.createVector(p.random(p.width), p.random(p.height));
          this.velocity = p.createVector(p.random(-2, 2), p.random(-2, 2));
          this.acceleration = p.createVector(0, 0);
          this.size = p.random(5, 15);
          this.color = p.color(p.random(255), 200, 255);
          this.maxSpeed = 4;
        }
        
        move() {
          // Create attraction to mouse
          if (p.mouseX > 0 && p.mouseY > 0) {
            let mouse = p.createVector(p.mouseX, p.mouseY);
            let dir = p5.Vector.sub(mouse, this.position);
            dir.normalize();
            dir.mult(0.5);
            this.acceleration = dir;
          }
          
          this.velocity.add(this.acceleration);
          this.velocity.limit(this.maxSpeed);
          this.position.add(this.velocity);
          this.acceleration.mult(0);
        }
        
        display() {
          p.noStroke();
          p.fill(this.color);
          p.ellipse(this.position.x, this.position.y, this.size, this.size);
        }
        
        checkEdges() {
          if (this.position.x > p.width) this.position.x = 0;
          if (this.position.x < 0) this.position.x = p.width;
          if (this.position.y > p.height) this.position.y = 0;
          if (this.position.y < 0) this.position.y = p.height;
        }
      }
      
      // Waves animation
      function drawWaves() {
        p.background(230, 30, 20);
        
        let waveCount = 5;
        let spacing = p.height / waveCount;
        
        for (let j = 0; j < waveCount; j++) {
          p.beginShape();
          
          let baseY = spacing * j + spacing / 2;
          let hue = (p.frameCount + j * 30) % 255;
          p.fill(hue, 200, 255, 150);
          p.noStroke();
          
          // Draw the wave
          p.vertex(0, p.height);
          for (let i = 0; i <= p.width; i += 10) {
            let xAngle = p.map(i, 0, p.width, 0, p.TWO_PI * 2);
            let yAngle = p.map(p.frameCount % 100, 0, 100, 0, p.TWO_PI);
            let amplitude = p.map(p.sin(xAngle * 0.5 + yAngle), -1, 1, 0, spacing * 0.8);
            
            let y = baseY + amplitude;
            p.vertex(i, y);
          }
          p.vertex(p.width, p.height);
          p.endShape(p.CLOSE);
        }
      }
      
      // Flocking animation
      function drawFlocking() {
        p.background(210, 30, 20);
        
        for (let boid of boids) {
          boid.flock(boids);
          boid.update();
          boid.edges();
          boid.show();
        }
      }
      
      class Boid {
        constructor(x, y) {
          this.position = p.createVector(x, y);
          this.velocity = p5.Vector.random2D();
          this.velocity.setMag(p.random(2, 4));
          this.acceleration = p.createVector();
          this.maxForce = 0.2;
          this.maxSpeed = 4;
          this.size = 5;
          this.color = p.color(p.random(255), 200, 255);
        }
        
        flock(boids) {
          let alignment = this.align(boids);
          let cohesion = this.cohesion(boids);
          let separation = this.separation(boids);
          
          alignment.mult(1.0);
          cohesion.mult(1.0);
          separation.mult(1.5);
          
          this.acceleration.add(alignment);
          this.acceleration.add(cohesion);
          this.acceleration.add(separation);
        }
        
        update() {
          this.position.add(this.velocity);
          this.velocity.add(this.acceleration);
          this.velocity.limit(this.maxSpeed);
          this.acceleration.mult(0);
        }
        
        show() {
          p.stroke(this.color);
          p.strokeWeight(2);
          p.fill(this.color);
          
          p.push();
          p.translate(this.position.x, this.position.y);
          p.rotate(this.velocity.heading());
          p.triangle(0, 0, -this.size * 2, this.size, -this.size * 2, -this.size);
          p.pop();
        }
        
        edges() {
          if (this.position.x > p.width) this.position.x = 0;
          if (this.position.x < 0) this.position.x = p.width;
          if (this.position.y > p.height) this.position.y = 0;
          if (this.position.y < 0) this.position.y = p.height;
        }
        
        align(boids) {
          let perceptionRadius = 50;
          let steering = p.createVector();
          let total = 0;
          
          for (let other of boids) {
            let d = p.dist(this.position.x, this.position.y, other.position.x, other.position.y);
            if (other != this && d < perceptionRadius) {
              steering.add(other.velocity);
              total++;
            }
          }
          
          if (total > 0) {
            steering.div(total);
            steering.setMag(this.maxSpeed);
            steering.sub(this.velocity);
            steering.limit(this.maxForce);
          }
          
          return steering;
        }
        
        separation(boids) {
          let perceptionRadius = 30;
          let steering = p.createVector();
          let total = 0;
          
          for (let other of boids) {
            let d = p.dist(this.position.x, this.position.y, other.position.x, other.position.y);
            if (other != this && d < perceptionRadius) {
              let diff = p5.Vector.sub(this.position, other.position);
              diff.div(d);
              steering.add(diff);
              total++;
            }
          }
          
          if (total > 0) {
            steering.div(total);
            steering.setMag(this.maxSpeed);
            steering.sub(this.velocity);
            steering.limit(this.maxForce);
          }
          
          return steering;
        }
        
        cohesion(boids) {
          let perceptionRadius = 50;
          let steering = p.createVector();
          let total = 0;
          
          for (let other of boids) {
            let d = p.dist(this.position.x, this.position.y, other.position.x, other.position.y);
            if (other != this && d < perceptionRadius) {
              steering.add(other.position);
              total++;
            }
          }
          
          if (total > 0) {
            steering.div(total);
            steering.sub(this.position);
            steering.setMag(this.maxSpeed);
            steering.sub(this.velocity);
            steering.limit(this.maxForce);
          }
          
          return steering;
        }
      }
      
      // Fireworks animation
      function drawFireworks() {
        p.background(0, 0, 20, 25);
        
        for (let i = fireworks.length - 1; i >= 0; i--) {
          fireworks[i].update();
          fireworks[i].show();
          
          if (fireworks[i].done()) {
            fireworks.splice(i, 1);
          }
        }
        
        // Automatically add fireworks occasionally
        if (fireworks.length < 5 && p.random(1) < 0.05) {
          fireworks.push(new Firework(p.random(p.width), p.height, p.random(p.width), p.random(p.height / 2)));
        }
      }
      
      class Firework {
        constructor(x1, y1, x2, y2) {
          this.firework = new FireworkParticle(x1, y1, true);
          this.target = p.createVector(x2, y2);
          this.exploded = false;
          this.particles = [];
          this.hue = p.random(255);
        }
        
        update() {
          if (!this.exploded) {
            this.firework.applyForce(gravity);
            this.firework.update();
            
            // Check if reached target or stopped moving up
            let d = p.dist(this.firework.pos.x, this.firework.pos.y, this.target.x, this.target.y);
            
            if (d < 10 || this.firework.vel.y >= 0) {
              this.exploded = true;
              this.explode();
            }
          }
          
          for (let i = this.particles.length - 1; i >= 0; i--) {
            this.particles[i].applyForce(gravity);
            this.particles[i].update();
            
            if (this.particles[i].isDead()) {
              this.particles.splice(i, 1);
            }
          }
        }
        
        explode() {
          const particleCount = 100;
          for (let i = 0; i < particleCount; i++) {
            const particle = new FireworkParticle(this.firework.pos.x, this.firework.pos.y, false);
            this.particles.push(particle);
          }
        }
        
        done() {
          return this.exploded && this.particles.length === 0;
        }
        
        show() {
          if (!this.exploded) {
            this.firework.show(this.hue);
          }
          
          for (let particle of this.particles) {
            particle.show(this.hue);
          }
        }
      }
      
      class FireworkParticle {
        constructor(x, y, isFirework) {
          this.pos = p.createVector(x, y);
          this.isFirework = isFirework;
          this.lifespan = 255;
          
          if (isFirework) {
            // Moving upward
            this.vel = p.createVector(0, p.random(-12, -8));
          } else {
            // Explosion particle
            this.vel = p5.Vector.random2D();
            this.vel.mult(p.random(2, 10));
          }
          
          this.acc = p.createVector(0, 0);
        }
        
        applyForce(force) {
          this.acc.add(force);
        }
        
        update() {
          if (!this.isFirework) {
            this.vel.mult(0.95);
            this.lifespan -= 4;
          }
          
          this.vel.add(this.acc);
          this.pos.add(this.vel);
          this.acc.mult(0);
        }
        
        show(hue) {
          if (!this.isFirework) {
            p.strokeWeight(2);
            p.stroke(hue, 255, 255, this.lifespan);
          } else {
            p.strokeWeight(4);
            p.stroke(hue, 255, 255);
          }
          
          p.point(this.pos.x, this.pos.y);
        }
        
        isDead() {
          return this.lifespan < 0;
        }
      }
      
      // Bubbles animation
      function drawBubbles() {
        p.background(200, 50, 40, 25);
        
        // Handle existing bubbles
        for (let i = bubbles.length - 1; i >= 0; i--) {
          bubbles[i].update();
          bubbles[i].display();
          
          // Remove bubbles that have moved off screen
          if (bubbles[i].isOffScreen()) {
            bubbles.splice(i, 1);
          }
        }
        
        // Add new bubbles occasionally
        if (p.frameCount % 5 === 0 && bubbles.length < 100) {
          bubbles.push(new Bubble());
        }
      }
      
      class Bubble {
        constructor() {
          this.x = p.random(p.width);
          this.y = p.height + p.random(20, 50);
          this.size = p.random(10, 60);
          this.speed = p.map(this.size, 10, 60, 2.5, 0.8);
          this.hue = p.random(255);
          this.alpha = p.random(100, 200);
          this.wobble = p.random(0.1, 0.3);
          this.wobbleSpeed = p.random(0.01, 0.05);
          this.wobbleOffset = p.random(p.TWO_PI);
          this.highlighted = false;
        }
        
        update() {
          this.y -= this.speed;
          this.x += p.sin((p.frameCount * this.wobbleSpeed) + this.wobbleOffset) * this.wobble;
          
          // Check if mouse is close
          let d = p.dist(p.mouseX, p.mouseY, this.x, this.y);
          if (d < this.size/1.5) {
            this.highlighted = true;
            // Add slight repulsion from mouse
            let angle = p.atan2(this.y - p.mouseY, this.x - p.mouseX);
            this.x += p.cos(angle) * 1;
            this.y += p.sin(angle) * 1;
          } else {
            this.highlighted = false;
          }
        }
        
        display() {
          p.noFill();
          let strokeAlpha = this.highlighted ? 255 : this.alpha;
          let strokeWeight = this.highlighted ? 3 : 2;
          
          // Main bubble
          p.strokeWeight(strokeWeight);
          p.stroke(this.hue, 200, 255, strokeAlpha);
          p.ellipse(this.x, this.y, this.size);
          
          // Highlight
          p.strokeWeight(1);
          p.stroke(this.hue, 100, 255, strokeAlpha * 0.7);
          let highlightSize = this.size * 0.3;
          let highlightX = this.x - this.size * 0.2;
          let highlightY = this.y - this.size * 0.2;
          p.ellipse(highlightX, highlightY, highlightSize);
        }
        
        isOffScreen() {
          return this.y < -this.size;
        }
      }
      
      // Matrix Digital Rain animation
      function initMatrix() {
        symbols = [];
        streams = [];
        
        const symbolSize = 14;
        const columnsCount = p.floor(p.width / symbolSize);
        
        for (let i = 0; i < columnsCount; i++) {
          const stream = new Stream();
          stream.generateSymbols(i * symbolSize, p.random(-1000, 0));
          streams.push(stream);
        }
      }
      
      function drawMatrix() {
        p.background(0, 0, 0, 20);
        
        streams.forEach(stream => {
          stream.render();
        });
      }
      
      class Symbol {
        constructor(x, y, speed, first, opacity) {
          this.x = x;
          this.y = y;
          this.value = "";
          this.speed = speed;
          this.switchInterval = p.round(p.random(5, 20));
          this.first = first;
          this.opacity = opacity;
          this.setToRandomSymbol();
        }
        
        setToRandomSymbol() {
          if (p.frameCount % this.switchInterval === 0) {
            // Use a mix of katakana characters and latin alphanumerics
            if (p.random(1) > 0.5) {
              // Katakana Unicode range
              this.value = String.fromCharCode(0x30A0 + p.round(p.random(0, 96)));
            } else {
              // Latin alphanumeric and some symbols
              const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789$+-*/=%\"'#&_(),.;:?!|{}[]<>~^";
              this.value = chars.charAt(p.floor(p.random(chars.length)));
            }
          }
        }
        
        update() {
          this.y = (this.y >= p.height) ? 0 : this.y + this.speed;
          this.setToRandomSymbol();
        }
        
        render() {
          // First character in the stream is white and brighter
          if (this.first) {
            p.fill(180, 50, 255, this.opacity);
            p.textStyle(p.BOLD);
          } else {
            p.fill(120, 255, 200, this.opacity);
            p.textStyle(p.NORMAL);
          }
          
          p.textSize(14);
          p.textAlign(p.CENTER, p.CENTER);
          p.text(this.value, this.x, this.y);
        }
      }
      
      class Stream {
        constructor() {
          this.symbols = [];
          this.totalSymbols = p.round(p.random(5, 30));
          this.speed = p.random(4, 10);
        }
        
        generateSymbols(x, y) {
          // First symbol is white and brighter
          let opacity = p.random(150, 255);
          let first = true;
          
          for (let i = 0; i < this.totalSymbols; i++) {
            const symbol = new Symbol(
              x,
              y,
              this.speed,
              first,
              opacity
            );
            
            symbol.setToRandomSymbol();
            this.symbols.push(symbol);
            opacity -= p.random(5, 15);
            opacity = p.max(opacity, 0);
            y -= p.random(14, 20);
            first = false;
          }
        }
        
        render() {
          this.symbols.forEach(symbol => {
            symbol.render();
            symbol.update();
          });
        }
      }
      
      // Starfield animation
      function drawStarfield() {
        p.background(0, 0, 5);
        // Translate to center of screen
        p.translate(p.width / 2, p.height / 2);
        
        for (let i = 0; i < stars.length; i++) {
          stars[i].update();
          stars[i].show();
        }
      }
      
      class Star {
        constructor() {
          this.reset();
          // Start stars at random distances
          this.z = p.random(0, p.width * 2);
        }
        
        reset() {
          this.x = p.random(-p.width, p.width);
          this.y = p.random(-p.height, p.height);
          this.z = p.width * 2;
          this.pz = this.z;
          this.size = p.random(0.5, 2);
          this.color = p.color(p.random(150, 255), p.random(0, 50), 255);
        }
        
        update() {
          this.pz = this.z;
          this.z -= 5; // Speed of moving through space
          
          if (this.z < 1) {
            this.reset();
          }
        }
        
        show() {
          let sx = p.map(this.x / this.z, 0, 1, 0, p.width);
          let sy = p.map(this.y / this.z, 0, 1, 0, p.height);
          
          let px = p.map(this.x / this.pz, 0, 1, 0, p.width);
          let py = p.map(this.y / this.pz, 0, 1, 0, p.height);
          
          let r = p.map(this.z, 0, p.width * 2, this.size * 3, 0);
          
          p.fill(this.color);
          p.noStroke();
          p.ellipse(sx, sy, r, r);
          
          // Draw "motion streak"
          p.stroke(this.color);
          p.strokeWeight(r * 0.5);
          p.line(sx, sy, px, py);
        }
      }
      
      // Geometric animation
      function initGeometric() {
        shapes = [];
        
        // Create random geometric shapes
        for (let i = 0; i < 15; i++) {
          shapes.push({
            type: p.floor(p.random(3)), // 0: circle, 1: rectangle, 2: triangle
            x: p.random(p.width),
            y: p.random(p.height),
            size: p.random(20, 80),
            rotation: p.random(p.TWO_PI),
            rotationSpeed: p.random(-0.02, 0.02),
            xSpeed: p.random(-1, 1),
            ySpeed: p.random(-1, 1),
            hue: p.random(255),
            saturation: p.random(150, 255),
            brightness: p.random(200, 255),
            alpha: p.random(150, 200)
          });
        }
      }
      
      function drawGeometric() {
        p.background(0, 0, 20, 10);
        
        // Update time variable for sine/cosine calculations
        time += 0.01;
        
        for (let shape of shapes) {
          // Update position
          shape.x += shape.xSpeed;
          shape.y += shape.ySpeed;
          
          // Bounce off edges
          if (shape.x < 0 || shape.x > p.width) shape.xSpeed *= -1;
          if (shape.y < 0 || shape.y > p.height) shape.ySpeed *= -1;
          
          // Update rotation
          shape.rotation += shape.rotationSpeed;
          
          // Pulse size with sine wave
          const pulseSize = shape.size + p.sin(time + shape.x * 0.01) * 10;
          
          // Shift hue slowly
          shape.hue = (shape.hue + 0.2) % 255;
          
          p.push();
          p.translate(shape.x, shape.y);
          p.rotate(shape.rotation);
          
          // Set fill and stroke
          p.noStroke();
          p.fill(shape.hue, shape.saturation, shape.brightness, shape.alpha);
          
          // Draw shape based on type
          if (shape.type === 0) {
            // Circle
            p.ellipse(0, 0, pulseSize, pulseSize);
          } else if (shape.type === 1) {
            // Rectangle
            p.rectMode(p.CENTER);
            p.rect(0, 0, pulseSize, pulseSize * 0.7);
          } else if (shape.type === 2) {
            // Triangle
            const halfSize = pulseSize / 2;
            p.triangle(0, -halfSize, halfSize, halfSize, -halfSize, halfSize);
          }
          
          p.pop();
        }
        
        // Occasionally add a new shape
        if (p.frameCount % 100 === 0 && shapes.length < 25) {
          shapes.push({
            type: p.floor(p.random(3)),
            x: p.random(p.width),
            y: p.random(p.height),
            size: p.random(20, 80),
            rotation: p.random(p.TWO_PI),
            rotationSpeed: p.random(-0.02, 0.02),
            xSpeed: p.random(-1, 1),
            ySpeed: p.random(-1, 1),
            hue: p.random(255),
            saturation: p.random(150, 255),
            brightness: p.random(200, 255),
            alpha: p.random(150, 200)
          });
        }
      }
      
      // Flow Field animation
      function initFlowField() {
        // Create a flow field grid
        const resolution = 20;
        const cols = Math.ceil(p.width / resolution);
        const rows = Math.ceil(p.height / resolution);
        
        flowField = new Array(cols * rows);
        
        // Initialize with Perlin noise
        let yoff = 0;
        for (let y = 0; y < rows; y++) {
          let xoff = 0;
          for (let x = 0; x < cols; x++) {
            const index = x + y * cols;
            const angle = p.noise(xoff, yoff, time * 0.1) * p.TWO_PI * 2;
            const v = p5.Vector.fromAngle(angle);
            v.setMag(1);
            flowField[index] = v;
            xoff += 0.1;
          }
          yoff += 0.1;
        }
        
        // Create particles that will follow the flow field
        flowParticles = [];
        for (let i = 0; i < 1000; i++) {
          flowParticles.push({
            pos: p.createVector(p.random(p.width), p.random(p.height)),
            vel: p.createVector(0, 0),
            acc: p.createVector(0, 0),
            maxSpeed: p.random(2, 5),
            color: p.color(p.random(255), 200, 255, 50),
            prevPos: null,
            updatePrev: function() {
              this.prevPos = p.createVector(this.pos.x, this.pos.y);
            },
            applyForce: function(force) {
              this.acc.add(force);
            },
            update: function() {
              this.updatePrev();
              this.vel.add(this.acc);
              this.vel.limit(this.maxSpeed);
              this.pos.add(this.vel);
              this.acc.mult(0);
              
              // Wrap around edges
              if (this.pos.x > p.width) this.pos.x = 0;
              if (this.pos.x < 0) this.pos.x = p.width;
              if (this.pos.y > p.height) this.pos.y = 0;
              if (this.pos.y < 0) this.pos.y = p.height;
              
              // If crossing an edge, don't draw a line
              if (this.prevPos) {
                if (p.abs(this.pos.x - this.prevPos.x) > p.width/2 || 
                    p.abs(this.pos.y - this.prevPos.y) > p.height/2) {
                  this.updatePrev();
                }
              }
            },
            follow: function(flowField) {
              // Find grid position
              const resolution = 20;
              const x = Math.floor(this.pos.x / resolution);
              const y = Math.floor(this.pos.y / resolution);
              const index = x + y * Math.ceil(p.width / resolution);
              
              // Get flow force
              if (index >= 0 && index < flowField.length) {
                const force = flowField[index];
                this.applyForce(force);
              }
            },
            show: function() {
              p.stroke(this.color);
              p.strokeWeight(1);
              if (this.prevPos) {
                p.line(this.pos.x, this.pos.y, this.prevPos.x, this.prevPos.y);
              }
            }
          });
          
          // Initialize prevPos
          flowParticles[i].updatePrev();
        }
      }
      
      function createVortex(x, y) {
        const resolution = 20;
        const cols = Math.ceil(p.width / resolution);
        const vortexStrength = 0.5;
        
        // Update flow field with vortex influence
        for (let i = 0; i < flowField.length; i++) {
          const fieldX = (i % cols) * resolution;
          const fieldY = Math.floor(i / cols) * resolution;
          
          // Calculate angle from mouse to field point
          const dx = fieldX - x;
          const dy = fieldY - y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < 100) {
            // Create swirling vortex effect
            const angle = Math.atan2(dy, dx) + (Math.PI/2) * (1 - distance/100);
            const influence = p.map(distance, 0, 100, vortexStrength, 0);
            
            // Blend original flow with vortex
            const vortexVector = p5.Vector.fromAngle(angle);
            vortexVector.mult(influence);
            flowField[i].add(vortexVector);
            flowField[i].setMag(1); // Normalize
          }
        }
      }
      
      function drawFlowField() {
        p.background(0, 0, 10, 25);
        
        // Update flow field over time
        if (p.frameCount % 10 === 0) {
          time += 0.01;
          const resolution = 20;
          const cols = Math.ceil(p.width / resolution);
          const rows = Math.ceil(p.height / resolution);
          
          let yoff = time;
          for (let y = 0; y < rows; y++) {
            let xoff = time;
            for (let x = 0; x < cols; x++) {
              const index = x + y * cols;
              const angle = p.noise(xoff, yoff, time) * p.TWO_PI * 4;
              const v = p5.Vector.fromAngle(angle);
              v.setMag(1);
              flowField[index] = v;
              xoff += 0.1;
            }
            yoff += 0.1;
          }
        }
        
        // Show and update particles
        for (let particle of flowParticles) {
          particle.follow(flowField);
          particle.update();
          particle.show();
        }
        
        // Display instructions
        p.fill(255);
        p.noStroke();
        p.textAlign(p.CENTER);
        p.textSize(18);
        p.text("Drag mouse to create vortices", p.width/2, 30);
      }
      
      // Physics Playground animation
      function initPhysics() {
        physicsBodies = [];
        gravity = p.createVector(0, 0.2);
        
        // Create some initial bodies
        for (let i = 0; i < 10; i++) {
          createPhysicsBody(p.random(p.width), p.random(p.height/2));
        }
      }
      
      function createPhysicsBody(x, y) {
        const body = {
          position: p.createVector(x, y),
          velocity: p.createVector(p.random(-1, 1), p.random(-2, 0)),
          acceleration: p.createVector(0, 0),
          radius: p.random(10, 30),
          mass: 0,
          restitution: 0.8, // Bounciness
          color: p.color(p.random(255), 200, 255),
          
          applyForce: function(force) {
            // F = ma, so a = F/m
            let f = p5.Vector.div(force, this.mass);
            this.acceleration.add(f);
          },
          
          update: function() {
            this.velocity.add(this.acceleration);
            this.position.add(this.velocity);
            this.acceleration.mult(0);
            
            // Check boundaries
            if (this.position.x > p.width - this.radius) {
              this.position.x = p.width - this.radius;
              this.velocity.x *= -this.restitution;
            }
            if (this.position.x < this.radius) {
              this.position.x = this.radius;
              this.velocity.x *= -this.restitution;
            }
            if (this.position.y > p.height - this.radius) {
              this.position.y = p.height - this.radius;
              this.velocity.y *= -this.restitution;
              // Add friction when on ground
              this.velocity.x *= 0.99;
            }
            if (this.position.y < this.radius) {
              this.position.y = this.radius;
              this.velocity.y *= -this.restitution;
            }
          },
          
          checkCollision: function(other) {
            // Simple circle-circle collision detection
            const d = p.dist(this.position.x, this.position.y, other.position.x, other.position.y);
            if (d < this.radius + other.radius) {
              // Calculate collision response
              const angle = Math.atan2(other.position.y - this.position.y, other.position.x - this.position.x);
              const targetX = this.position.x + Math.cos(angle) * (this.radius + other.radius);
              const targetY = this.position.y + Math.sin(angle) * (this.radius + other.radius);
              const ax = (targetX - other.position.x) * 0.05;
              const ay = (targetY - other.position.y) * 0.05;
              
              this.velocity.x -= ax * other.mass / this.mass;
              this.velocity.y -= ay * other.mass / this.mass;
              other.velocity.x += ax * this.mass / other.mass;
              other.velocity.y += ay * this.mass / other.mass;
              
              // Add a little damping to the collision
              this.velocity.mult(0.99);
              other.velocity.mult(0.99);
            }
          },
          
          display: function() {
            p.noStroke();
            p.fill(this.color);
            p.ellipse(this.position.x, this.position.y, this.radius * 2);
            
            // Add a highlight
            p.fill(255, 50);
            p.ellipse(this.position.x - this.radius * 0.3, this.position.y - this.radius * 0.3, this.radius * 0.8);
          }
        };
        
        // Set mass based on radius (volume)
        body.mass = body.radius * body.radius * p.PI;
        
        physicsBodies.push(body);
        
        // Remove old bodies if we have too many
        if (physicsBodies.length > 30) {
          physicsBodies.shift();
        }
      }
      
      function drawPhysics() {
        p.background(230, 30, 20);
        
        // Draw ground
        p.noStroke();
        p.fill(200, 30, 100);
        p.rect(0, p.height - 20, p.width, 20);
        
        // Update physics bodies
        for (let i = 0; i < physicsBodies.length; i++) {
          // Apply gravity
          const gravityForce = p5.Vector.mult(gravity, physicsBodies[i].mass);
          physicsBodies[i].applyForce(gravityForce);
          
          // Check collisions with other bodies
          for (let j = i + 1; j < physicsBodies.length; j++) {
            physicsBodies[i].checkCollision(physicsBodies[j]);
          }
          
          physicsBodies[i].update();
          physicsBodies[i].display();
        }
        
        // Display instructions
        p.fill(255);
        p.noStroke();
        p.textAlign(p.CENTER);
        p.textSize(18);
        p.text("Click to add physics objects", p.width/2, 30);
      }
      
      // Audio Visualization animation
      function initAudio() {
        audioWaves = [];
        audioLevel = 0;
      }
      
      function createAudioPulse(x, y) {
        // Create a new expanding wave
        audioWaves.push({
          x: x,
          y: y,
          radius: 0,
          maxRadius: p.random(100, 300),
          speed: p.random(2, 5),
          color: p.color(p.random(255), 200, 255, 100),
          lineWeight: p.random(2, 6)
        });
        
        // Boost audio level
        audioLevel = 1;
      }
      
      function drawAudio() {
        p.background(0, 0, 20);
        
        // Calculate the beat visualization
        if (audioLevel > 0) {
          audioLevel *= 0.95; // Decay
        }
        
        // Draw center audio visualizer
        const centerX = p.width / 2;
        const centerY = p.height / 2;
        const baseBars = 128;
        const barWidth = (p.TWO_PI) / baseBars;
        
        for (let i = 0; i < baseBars; i++) {
          const angle = i * barWidth;
          
          // Calculate bar height using sin and audioLevel
          const barHeight = 50 + Math.sin(angle * 8 + time) * 20 * (1 + audioLevel * 2);
          const barHeight2 = 100 + Math.sin(angle * 4 + time * 2) * 30 * (1 + audioLevel);
          
          // Get coordinates for the bars
          const x1 = centerX + Math.cos(angle) * 30;
          const y1 = centerY + Math.sin(angle) * 30;
          const x2 = centerX + Math.cos(angle) * barHeight;
          const y2 = centerY + Math.sin(angle) * barHeight;
          const x3 = centerX + Math.cos(angle) * barHeight2;
          const y3 = centerY + Math.sin(angle) * barHeight2;
          
          // Draw inner bar (more white)
          p.strokeWeight(2);
          p.stroke(time * 10 % 255, 150, 255, 200 * (1 - audioLevel) + 50);
          p.line(x1, y1, x2, y2);
          
          // Draw outer bar (more colorful)
          p.strokeWeight(1);
          p.stroke((time * 5 + i) % 255, 200, 255, 150 * audioLevel + 50);
          p.line(x2, y2, x3, y3);
        }
        
        // Draw frequency circles
        p.noFill();
        for (let j = 0; j < 3; j++) {
          const radius = 150 + j * 30 + audioLevel * 20;
          p.strokeWeight(2 + audioLevel * 3);
          p.stroke((time * 20 + j * 60) % 255, 200, 255, 100);
          p.ellipse(centerX, centerY, radius * 2);
        }
        
        // Update and draw audio waves
        for (let i = audioWaves.length - 1; i >= 0; i--) {
          const wave = audioWaves[i];
          
          // Update
          wave.radius += wave.speed;
          
          // Draw
          p.noFill();
          p.strokeWeight(wave.lineWeight);
          p.stroke(wave.color);
          p.ellipse(wave.x, wave.y, wave.radius * 2);
          
          // Remove if too large
          if (wave.radius > wave.maxRadius) {
            audioWaves.splice(i, 1);
          }
        }
        
        // Increment time
        time += 0.05;
        
        // Display instructions
        p.fill(255);
        p.noStroke();
        p.textAlign(p.CENTER);
        p.textSize(18);
        p.text("Click anywhere to create sound waves", p.width/2, 30);
      }
      
      // Neural Network animation
      function initNeuralNetwork() {
        // Create neurons in a network layout
        neurons = [];
        connections = [];
        
        // Input layer (2 neurons - x,y)
        const inputLayer = [];
        for (let i = 0; i < 2; i++) {
          const neuron = {
            x: 100,
            y: 150 + i * 100,
            value: 0,
            layer: 0,
            radius: 15,
            color: p.color(30, 200, 255)
          };
          neurons.push(neuron);
          inputLayer.push(neuron);
        }
        
        // Hidden layer (4 neurons)
        const hiddenLayer = [];
        for (let i = 0; i < 4; i++) {
          const neuron = {
            x: 250,
            y: 100 + i * 70,
            value: 0,
            layer: 1,
            radius: 15,
            color: p.color(150, 200, 255)
          };
          neurons.push(neuron);
          hiddenLayer.push(neuron);
        }
        
        // Output layer (2 neurons - prediction x,y)
        const outputLayer = [];
        for (let i = 0; i < 2; i++) {
          const neuron = {
            x: 400,
            y: 150 + i * 100,
            value: 0,
            layer: 2,
            radius: 15,
            color: p.color(200, 200, 255)
          };
          neurons.push(neuron);
          outputLayer.push(neuron);
        }
        
        // Create connections with random weights
        // Input to hidden
        for (let i = 0; i < inputLayer.length; i++) {
          for (let j = 0; j < hiddenLayer.length; j++) {
            connections.push({
              from: inputLayer[i],
              to: hiddenLayer[j],
              weight: p.random(-1, 1),
              color: p.color(p.random(255), 150, 255, 100)
            });
          }
        }
        
        // Hidden to output
        for (let i = 0; i < hiddenLayer.length; i++) {
          for (let j = 0; j < outputLayer.length; j++) {
            connections.push({
              from: hiddenLayer[i],
              to: outputLayer[j],
              weight: p.random(-1, 1),
              color: p.color(p.random(255), 150, 255, 100)
            });
          }
        }
        
        trainingData = [];
        
        // Create initial path to follow
        const pathPoints = 100;
        for (let i = 0; i < pathPoints; i++) {
          const angle = (i / pathPoints) * p.TWO_PI;
          const radius = 50 + Math.sin(angle * 3) * 20;
          const x = p.width/2 + Math.cos(angle) * radius;
          const y = p.height/2 + Math.sin(angle) * radius;
          trainingData.push({x: x, y: y});
        }
      }
      
      function trainNeuralNetwork(data) {
        // Very simplified network training visualization
        // In a real neural network, we'd use backpropagation
        
        // Update connection weights based on new data
        for (let connection of connections) {
          // Slightly adjust weights - this is just for visualization
          connection.weight += p.random(-0.1, 0.1);
          connection.weight = p.constrain(connection.weight, -1, 1);
          
          // Update connection color based on weight
          const hue = p.map(connection.weight, -1, 1, 0, 255);
          connection.color = p.color(hue, 200, 255, 150);
        }
      }
      
      function drawNeuralNetwork() {
        p.background(0, 0, 20);
        
        // Draw connections
        for (let connection of connections) {
          p.strokeWeight(p.map(Math.abs(connection.weight), 0, 1, 1, 4));
          p.stroke(connection.color);
          p.line(connection.from.x, connection.from.y, connection.to.x, connection.to.y);
        }
        
        // Draw neurons
        for (let neuron of neurons) {
          p.fill(neuron.color);
          p.stroke(255);
          p.strokeWeight(1);
          p.ellipse(neuron.x, neuron.y, neuron.radius * 2);
          
          // Highlight active neurons
          if (neuron.value > 0.5) {
            p.noFill();
            p.strokeWeight(2);
            p.stroke(255, 255, 255, 150);
            p.ellipse(neuron.x, neuron.y, neuron.radius * 2.5);
          }
        }
        
        // Draw path of training data
        if (trainingData.length > 1) {
          p.stroke(255, 100);
          p.strokeWeight(2);
          p.noFill();
          p.beginShape();
          for (let point of trainingData) {
            p.vertex(point.x, point.y);
          }
          p.endShape();
        }
        
        // Update network input with mouse
        if (p.mouseX > 0 && p.mouseX < p.width && p.mouseY > 0 && p.mouseY < p.height) {
          // Update input neurons with normalized mouse position
          neurons[0].value = p.map(p.mouseX, 0, p.width, 0, 1);
          neurons[1].value = p.map(p.mouseY, 0, p.height, 0, 1);
          
          // Feed forward through network
          for (let i = 2; i < neurons.length; i++) {
            // Reset hidden and output neurons
            neurons[i].value = 0;
          }
          
          // Simple feed-forward calculation
          for (let connection of connections) {
            connection.to.value += connection.from.value * connection.weight;
          }
          
          // Apply activation function (simplified sigmoid)
          for (let i = 2; i < neurons.length; i++) {
            neurons[i].value = 1 / (1 + Math.exp(-neurons[i].value));
          }
          
          // Visualize network output
          const outX = p.map(neurons[neurons.length-2].value, 0, 1, 0, p.width);
          const outY = p.map(neurons[neurons.length-1].value, 0, 1, 0, p.height);
          
          p.fill(0, 255, 255);
          p.noStroke();
          p.ellipse(outX, outY, 10, 10);
        }
        
        // Display instructions
        p.fill(255);
        p.noStroke();
        p.textAlign(p.CENTER);
        p.textSize(18);
        p.text("Draw patterns with your mouse to train the network", p.width/2, 30);
      }
    };
    
    // Randomly select an animation on page load
    document.addEventListener('DOMContentLoaded', function() {
      const animations = ['particles', 'waves', 'flocking', 'fireworks', 'bubbles', 'matrix', 'starfield', 'geometric', 'flow', 'physics', 'audio', 'neural'];
      const randomAnimation = animations[Math.floor(Math.random() * animations.length)];
      switchAnimation(randomAnimation);
    });
  </script>
</body>
</html> 