<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Random Animation Gallery</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:400,500,700&display=swap">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <script src="https://cdn.jsdelivr.net/npm/p5@1.7.0/lib/p5.js"></script>
  <style>
    :root {
      --primary-color: #4a6fa5;
      --secondary-color: #6e9887;
      --accent-color: #ffc107;
      --light-bg: #f8f9fa;
      --dark-text: #333;
    }
    
    body {
      font-family: 'Roboto', sans-serif;
      background-color: var(--light-bg);
      color: var(--dark-text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }
    
    .site-header {
      background-color: white;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      padding: 1rem 0;
      margin-bottom: 2rem;
    }
    
    .site-title {
      color: var(--primary-color);
      font-weight: 700;
      margin-bottom: 0;
    }
    
    .navbar-custom {
      background-color: white;
      padding: 0.5rem 1rem;
    }
    
    .navbar-custom .nav-link {
      color: var(--primary-color);
      font-weight: 500;
      margin: 0 0.5rem;
      transition: color 0.3s ease;
    }
    
    .navbar-custom .nav-link:hover {
      color: var(--secondary-color);
    }
    
    main {
      margin-bottom: 3rem;
    }
    
    .animation-container {
      margin-bottom: 2rem;
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 6px 15px rgba(0,0,0,0.1);
      transition: transform 0.3s ease;
    }
    
    .animation-container:hover {
      transform: translateY(-5px);
    }
    
    .control-panel {
      background-color: white;
      padding: 1.5rem;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.08);
      margin-bottom: 2rem;
    }
    
    .btn-animation {
      background-color: var(--primary-color);
      color: white;
      border: none;
      margin-right: 0.5rem;
      transition: background-color 0.3s;
    }
    
    .btn-animation:hover {
      background-color: #3a5a80;
    }
    
    #currentAnimation {
      font-weight: 600;
      color: var(--primary-color);
    }
    
    footer {
      background-color: white;
      padding: 1.5rem 0;
      margin-top: auto;
      box-shadow: 0 -2px 10px rgba(0,0,0,0.05);
    }
    
    canvas {
      display: block;
      margin: 0 auto;
    }
  </style>
</head>
<body>
  <header class="site-header">
    <div class="container">
      <nav class="navbar navbar-expand-lg navbar-custom">
        <a class="navbar-brand" href="/">
          <h1 class="site-title">Product Showcase</h1>
        </a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarNav">
          <ul class="navbar-nav ml-auto">
            <li class="nav-item">
              <a class="nav-link" href="/">Home</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="/#products">Products</a>
            </li>
            <li class="nav-item active">
              <a class="nav-link" href="/animations">Animations</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="/#about">About</a>
            </li>
          </ul>
        </div>
      </nav>
    </div>
  </header>
  
  <main class="container">
    <h2 class="text-center mb-4">
      <i class="fas fa-magic text-primary mr-2"></i>
      Animation Gallery
    </h2>
    
    <div class="control-panel">
      <div class="d-flex align-items-center justify-content-between mb-3">
        <h4 class="mb-0">Choose Animation</h4>
        <div>
          <span>Current: <span id="currentAnimation">Particles</span></span>
        </div>
      </div>
      <div>
        <button class="btn btn-animation" onclick="switchAnimation('particles')">Particles</button>
        <button class="btn btn-animation" onclick="switchAnimation('waves')">Waves</button>
        <button class="btn btn-animation" onclick="switchAnimation('flocking')">Flocking</button>
        <button class="btn btn-animation" onclick="switchAnimation('fireworks')">Fireworks</button>
        <button class="btn btn-animation" onclick="switchAnimation('bubbles')">Bubbles</button>
        <button class="btn btn-animation" onclick="switchAnimation('matrix')">Matrix</button>
        <button class="btn btn-animation" onclick="switchAnimation('starfield')">Starfield</button>
        <button class="btn btn-animation" onclick="switchAnimation('geometric')">Geometric</button>
        <button class="btn btn-animation" onclick="switchAnimation('flow')">Flow Field</button>
        <button class="btn btn-animation" onclick="switchAnimation('physics')">Physics</button>
        <button class="btn btn-animation" onclick="switchAnimation('audio')">Audio Viz</button>
        <button class="btn btn-animation" onclick="switchAnimation('neural')">Neural Net</button>
        <button class="btn btn-animation btn-info" onclick="switchAnimation('kaleidoscope')">Kaleidoscope ‚ú®</button>
        <button class="btn btn-animation btn-info" onclick="switchAnimation('terrain')">3D Terrain üèîÔ∏è</button>
        <button class="btn btn-animation btn-info" onclick="switchAnimation('cloth')">Cloth Sim üí®</button>
      </div>
    </div>
    
    <div class="animation-container" id="canvasContainer">
      <!-- P5.js canvas will be inserted here -->
    </div>
    
    <div class="card">
      <div class="card-body">
        <h4 class="card-title">About This Animation</h4>
        <p class="card-text" id="animationDescription">
          Interactive particle system that responds to your mouse movements. Move your cursor across the canvas to interact with the particles.
        </p>
      </div>
    </div>
  </main>
  
  <footer>
    <div class="container text-center">
      <span class="text-muted">Siddharth Kulkarni ¬© 2025. All rights reserved.</span>
    </div>
  </footer>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>
  
  <script>
    // Animation state
    let currentAnimationType = 'particles';
    let p5Instance = null;
    
    // Function to switch between animations
    function switchAnimation(type) {
      currentAnimationType = type;
      document.getElementById('currentAnimation').textContent = type.charAt(0).toUpperCase() + type.slice(1);
      
      // Update description
      const descriptions = {
        particles: "Interactive particle system that responds to your mouse movements. Move your cursor across the canvas to interact with the particles.",
        waves: "Mesmerizing wave animation using sine waves with randomized colors. The waves flow across the screen creating beautiful patterns.",
        flocking: "Simulation of flocking behavior (boids algorithm) where entities follow simple rules to create complex behaviors.",
        fireworks: "Celebratory fireworks that burst into colorful particles. Click anywhere on the canvas to launch fireworks.",
        bubbles: "Colorful bubbles that float gently upward with a dreamy, underwater effect. Hover over bubbles to interact with them.",
        matrix: "Digital rain inspired by The Matrix movie. Characters stream down in a cyberpunk visual aesthetic.",
        starfield: "A mesmerizing journey through a 3D star field, creating the illusion of moving through space.",
        geometric: "Abstract geometric patterns that transform and evolve, creating a hypnotic visual experience.",
        flow: "Dynamic flow field where particles follow naturally curved paths. Move your mouse to create swirling vortexes and patterns.",
        physics: "Interactive physics playground with realistic gravity and collisions. Click to create objects and watch them interact.",
        audio: "Audio visualization that pulses with beat detection. Click anywhere to generate sound waves and see them visualized.",
        neural: "Artificial neural network simulation that learns to follow your movements. Train it by drawing patterns with your mouse.",
        kaleidoscope: "Draw with your mouse to create beautiful, symmetrical patterns. The kaleidoscope effect reflects your drawing across multiple axes. Press any key to clear the canvas.",
        terrain: "Fly over a procedurally generated 3D landscape. The terrain is created using Perlin noise. Use your mouse to look around.",
        cloth: "An interactive cloth simulation using Verlet integration. Click and drag points to move the cloth. Right-click and drag to tear it."
      };
      
      document.getElementById('animationDescription').textContent = descriptions[type];
      
      // Remove previous sketch if exists
      if (p5Instance) {
        p5Instance.remove();
      }
      
      // Create new sketch
      p5Instance = new p5(sketch, 'canvasContainer');
    }
    
    // P5.js sketch function
    const sketch = function(p) {
      // Variables for different animations
      let particles = [];
      let boids = [];
      let fireworks = [];
      let bubbles = [];
      let symbols = [];
      let streams = [];
      let stars = [];
      let shapes = [];
      let flowField = [];
      let flowParticles = [];
      let physicsBodies = [];
      let audioWaves = [];
      let audioLevel = 0;
      let neurons = [];
      let connections = [];
      let trainingData = [];
      let gravity;
      let time = 0;

      // Neural network helpers
      const neuralArchitecture = [3, 5, 4, 2];
      const NEURAL_LEARNING_RATE = 0.35;
      const MAX_NEURAL_WEIGHT = 3;
      let neuralLayerRanges = [];
      let neuralTrainingSamples = [];
      let neuralPredictionPath = [];
      let neuralTrainingLoss = null;
      let neuralAutoProgress = 0;
      
      // Kaleidoscope variables
      let symmetry = 6;
      let angle;
      let kaleidoscopeBrushSize = 4;
      let kaleidoscopeHue = 0;

      // 3D Terrain variables
      let cols, rows;
      let scl = 20;
      let w = 1400;
      let h = 1000;
      let flying = 0;
      let terrain = [];
      
      // Cloth simulation variables
      let clothPoints = [];
      let clothSticks = [];
      let draggedPoint = null;
      let clothGravity;

      p.setup = function() {
        const container = document.getElementById('canvasContainer');
        let canvas;
        if (currentAnimationType === 'terrain') {
          canvas = p.createCanvas(container.offsetWidth, 400, p.WEBGL);
        } else {
          canvas = p.createCanvas(container.offsetWidth, 400);
        }
        p.colorMode(p.HSB, 255);
        
        // Initialize based on animation type
        if (currentAnimationType === 'particles') {
          // Initialize particles
          for (let i = 0; i < 100; i++) {
            particles.push(new Particle());
          }
        } else if (currentAnimationType === 'flocking') {
          // Initialize boids
          for (let i = 0; i < 50; i++) {
            boids.push(new Boid(p.random(p.width), p.random(p.height)));
          }
        } else if (currentAnimationType === 'fireworks') {
          // Initialize gravity for fireworks
          gravity = p.createVector(0, 0.2);
        } else if (currentAnimationType === 'bubbles') {
          // Initialize bubbles
          for (let i = 0; i < 40; i++) {
            bubbles.push(new Bubble());
          }
        } else if (currentAnimationType === 'matrix') {
          // Initialize matrix columns
          initMatrix();
        } else if (currentAnimationType === 'starfield') {
          // Initialize stars
          for (let i = 0; i < 800; i++) {
            stars.push(new Star());
          }
        } else if (currentAnimationType === 'geometric') {
          // Initialize geometric shapes
          initGeometric();
        } else if (currentAnimationType === 'flow') {
          // Initialize flow field
          initFlowField();
        } else if (currentAnimationType === 'physics') {
          // Initialize physics playground
          initPhysics();
        } else if (currentAnimationType === 'audio') {
          // Initialize audio visualization
          initAudio();
        } else if (currentAnimationType === 'neural') {
          // Initialize neural network
          initNeuralNetwork();
        } else if (currentAnimationType === 'kaleidoscope') {
          initKaleidoscope();
        } else if (currentAnimationType === 'terrain') {
          initTerrain();
        } else if (currentAnimationType === 'cloth') {
          initCloth();
        }
      };
      
      p.draw = function() {
        if (currentAnimationType === 'particles') {
          drawParticles();
        } else if (currentAnimationType === 'waves') {
          drawWaves();
        } else if (currentAnimationType === 'flocking') {
          drawFlocking();
        } else if (currentAnimationType === 'fireworks') {
          drawFireworks();
        } else if (currentAnimationType === 'bubbles') {
          drawBubbles();
        } else if (currentAnimationType === 'matrix') {
          drawMatrix();
        } else if (currentAnimationType === 'starfield') {
          drawStarfield();
        } else if (currentAnimationType === 'geometric') {
          drawGeometric();
        } else if (currentAnimationType === 'flow') {
          drawFlowField();
        } else if (currentAnimationType === 'physics') {
          drawPhysics();
        } else if (currentAnimationType === 'audio') {
          drawAudio();
        } else if (currentAnimationType === 'neural') {
          drawNeuralNetwork();
        } else if (currentAnimationType === 'kaleidoscope') {
          drawKaleidoscope();
        } else if (currentAnimationType === 'terrain') {
          drawTerrain();
        } else if (currentAnimationType === 'cloth') {
          drawCloth();
        }
      };
      
      p.windowResized = function() {
        const container = document.getElementById('canvasContainer');
        p.resizeCanvas(container.offsetWidth, 400);
        // Re-initialize animations that depend on screen size
        if (currentAnimationType === 'terrain') initTerrain();
        if (currentAnimationType === 'cloth') initCloth();
      };

      p.keyPressed = function() {
        if (currentAnimationType === 'kaleidoscope') {
          p.background(0, 0, 10);
        }
      };
      
      p.mousePressed = function() {
        if (currentAnimationType === 'fireworks' && 
            p.mouseX > 0 && p.mouseX < p.width && 
            p.mouseY > 0 && p.mouseY < p.height) {
          fireworks.push(new Firework(p.mouseX, p.height, p.mouseX, p.mouseY));
        } else if (currentAnimationType === 'physics' && 
            p.mouseX > 0 && p.mouseX < p.width && 
            p.mouseY > 0 && p.mouseY < p.height) {
          createPhysicsBody(p.mouseX, p.mouseY);
        } else if (currentAnimationType === 'audio' && 
            p.mouseX > 0 && p.mouseX < p.width && 
            p.mouseY > 0 && p.mouseY < p.height) {
          createAudioPulse(p.mouseX, p.mouseY);
        }
        
        if (currentAnimationType === 'neural' && 
            p.mouseX > 0 && p.mouseX < p.width && 
            p.mouseY > 0 && p.mouseY < p.height) {
          trainingData = [];
          trainingData.push({x: p.mouseX, y: p.mouseY});
        }
        
        if (currentAnimationType === 'cloth' && p.mouseButton === p.LEFT) {
          let closestDist = Infinity;
          for (let point of clothPoints) {
            const d = p.dist(p.mouseX, p.mouseY, point.pos.x, point.pos.y);
            if (d < 20 && d < closestDist) {
              closestDist = d;
              draggedPoint = point;
            }
          }
        }
      };
      
      p.mouseDragged = function() {
        if (currentAnimationType === 'neural' && 
            p.mouseX > 0 && p.mouseX < p.width && 
            p.mouseY > 0 && p.mouseY < p.height) {
          trainingData.push({x: p.mouseX, y: p.mouseY});
        } else if (currentAnimationType === 'flow' && 
            p.mouseX > 0 && p.mouseX < p.width && 
            p.mouseY > 0 && p.mouseY < p.height) {
          // Create a vortex at the mouse position
          createVortex(p.mouseX, p.mouseY);
        }

        if (currentAnimationType === 'cloth') {
          if (draggedPoint) {
            draggedPoint.pos.set(p.mouseX, p.mouseY);
          } else if (p.mouseButton === p.RIGHT) {
            // Tear cloth
            for (let i = clothSticks.length - 1; i >= 0; i--) {
              if (clothSticks[i].isNearMouse(p.mouseX, p.mouseY, p.pmouseX, p.pmouseY)) {
                clothSticks.splice(i, 1);
              }
            }
          }
        }
      };
      
      p.mouseReleased = function() {
        if (currentAnimationType === 'neural' && trainingData.length > 5) {
          trainNeuralNetwork(trainingData);
        }
        if (currentAnimationType === 'cloth') {
          draggedPoint = null;
        }
      };
      
      // Particles animation
      function drawParticles() {
        p.background(230, 50, 15);
        
        for (let i = 0; i < particles.length; i++) {
          let particle = particles[i];
          particle.move();
          particle.display();
          particle.checkEdges();
        }
      }
      
      class Particle {
        constructor() {
          this.position = p.createVector(p.random(p.width), p.random(p.height));
          this.velocity = p.createVector(p.random(-2, 2), p.random(-2, 2));
          this.acceleration = p.createVector(0, 0);
          this.size = p.random(5, 15);
          this.color = p.color(p.random(255), 200, 255);
          this.maxSpeed = 4;
        }
        
        move() {
          // Create attraction to mouse
          if (p.mouseX > 0 && p.mouseY > 0) {
            let mouse = p.createVector(p.mouseX, p.mouseY);
            let dir = p5.Vector.sub(mouse, this.position);
            dir.normalize();
            dir.mult(0.5);
            this.acceleration = dir;
          }
          
          this.velocity.add(this.acceleration);
          this.velocity.limit(this.maxSpeed);
          this.position.add(this.velocity);
          this.acceleration.mult(0);
        }
        
        display() {
          p.noStroke();
          p.fill(this.color);
          p.ellipse(this.position.x, this.position.y, this.size, this.size);
        }
        
        checkEdges() {
          if (this.position.x > p.width) this.position.x = 0;
          if (this.position.x < 0) this.position.x = p.width;
          if (this.position.y > p.height) this.position.y = 0;
          if (this.position.y < 0) this.position.y = p.height;
        }
      }
      
      // Waves animation
      function drawWaves() {
        p.background(230, 30, 20);
        
        let waveCount = 5;
        let spacing = p.height / waveCount;
        
        for (let j = 0; j < waveCount; j++) {
          p.beginShape();
          
          let baseY = spacing * j + spacing / 2;
          let hue = (p.frameCount + j * 30) % 255;
          p.fill(hue, 200, 255, 150);
          p.noStroke();
          
          // Draw the wave
          p.vertex(0, p.height);
          for (let i = 0; i <= p.width; i += 10) {
            let xAngle = p.map(i, 0, p.width, 0, p.TWO_PI * 2);
            let yAngle = p.map(p.frameCount % 100, 0, 100, 0, p.TWO_PI);
            let amplitude = p.map(p.sin(xAngle * 0.5 + yAngle), -1, 1, 0, spacing * 0.8);
            
            let y = baseY + amplitude;
            p.vertex(i, y);
          }
          p.vertex(p.width, p.height);
          p.endShape(p.CLOSE);
        }
      }
      
      // Flocking animation
      function drawFlocking() {
        p.background(210, 30, 20);
        
        for (let boid of boids) {
          boid.flock(boids);
          boid.update();
          boid.edges();
          boid.show();
        }
      }
      
      class Boid {
        constructor(x, y) {
          this.position = p.createVector(x, y);
          this.velocity = p5.Vector.random2D();
          this.velocity.setMag(p.random(2, 4));
          this.acceleration = p.createVector();
          this.maxForce = 0.2;
          this.maxSpeed = 4;
          this.size = 5;
          this.color = p.color(p.random(255), 200, 255);
        }
        
        flock(boids) {
          let alignment = this.align(boids);
          let cohesion = this.cohesion(boids);
          let separation = this.separation(boids);
          
          alignment.mult(1.0);
          cohesion.mult(1.0);
          separation.mult(1.5);
          
          this.acceleration.add(alignment);
          this.acceleration.add(cohesion);
          this.acceleration.add(separation);
        }
        
        update() {
          this.position.add(this.velocity);
          this.velocity.add(this.acceleration);
          this.velocity.limit(this.maxSpeed);
          this.acceleration.mult(0);
        }
        
        show() {
          p.stroke(this.color);
          p.strokeWeight(2);
          p.fill(this.color);
          
          p.push();
          p.translate(this.position.x, this.position.y);
          p.rotate(this.velocity.heading());
          p.triangle(0, 0, -this.size * 2, this.size, -this.size * 2, -this.size);
          p.pop();
        }
        
        edges() {
          if (this.position.x > p.width) this.position.x = 0;
          if (this.position.x < 0) this.position.x = p.width;
          if (this.position.y > p.height) this.position.y = 0;
          if (this.position.y < 0) this.position.y = p.height;
        }
        
        align(boids) {
          let perceptionRadius = 50;
          let steering = p.createVector();
          let total = 0;
          
          for (let other of boids) {
            let d = p.dist(this.position.x, this.position.y, other.position.x, other.position.y);
            if (other != this && d < perceptionRadius) {
              steering.add(other.velocity);
              total++;
            }
          }
          
          if (total > 0) {
            steering.div(total);
            steering.setMag(this.maxSpeed);
            steering.sub(this.velocity);
            steering.limit(this.maxForce);
          }
          
          return steering;
        }
        
        separation(boids) {
          let perceptionRadius = 30;
          let steering = p.createVector();
          let total = 0;
          
          for (let other of boids) {
            let d = p.dist(this.position.x, this.position.y, other.position.x, other.position.y);
            if (other != this && d < perceptionRadius) {
              let diff = p5.Vector.sub(this.position, other.position);
              diff.div(d);
              steering.add(diff);
              total++;
            }
          }
          
          if (total > 0) {
            steering.div(total);
            steering.setMag(this.maxSpeed);
            steering.sub(this.velocity);
            steering.limit(this.maxForce);
          }
          
          return steering;
        }
        
        cohesion(boids) {
          let perceptionRadius = 50;
          let steering = p.createVector();
          let total = 0;
          
          for (let other of boids) {
            let d = p.dist(this.position.x, this.position.y, other.position.x, other.position.y);
            if (other != this && d < perceptionRadius) {
              steering.add(other.position);
              total++;
            }
          }
          
          if (total > 0) {
            steering.div(total);
            steering.sub(this.position);
            steering.setMag(this.maxSpeed);
            steering.sub(this.velocity);
            steering.limit(this.maxForce);
          }
          
          return steering;
        }
      }
      
      // Fireworks animation
      function drawFireworks() {
        p.background(0, 0, 20, 25);
        
        for (let i = fireworks.length - 1; i >= 0; i--) {
          fireworks[i].update();
          fireworks[i].show();
          
          if (fireworks[i].done()) {
            fireworks.splice(i, 1);
          }
        }
        
        // Automatically add fireworks occasionally
        if (fireworks.length < 5 && p.random(1) < 0.05) {
          fireworks.push(new Firework(p.random(p.width), p.height, p.random(p.width), p.random(p.height / 2)));
        }
      }
      
      class Firework {
        constructor(x1, y1, x2, y2) {
          this.firework = new FireworkParticle(x1, y1, true);
          this.target = p.createVector(x2, y2);
          this.exploded = false;
          this.particles = [];
          this.hue = p.random(255);
        }
        
        update() {
          if (!this.exploded) {
            this.firework.applyForce(gravity);
            this.firework.update();
            
            // Check if reached target or stopped moving up
            let d = p.dist(this.firework.pos.x, this.firework.pos.y, this.target.x, this.target.y);
            
            if (d < 10 || this.firework.vel.y >= 0) {
              this.exploded = true;
              this.explode();
            }
          }
          
          for (let i = this.particles.length - 1; i >= 0; i--) {
            this.particles[i].applyForce(gravity);
            this.particles[i].update();
            
            if (this.particles[i].isDead()) {
              this.particles.splice(i, 1);
            }
          }
        }
        
        explode() {
          const particleCount = 100;
          for (let i = 0; i < particleCount; i++) {
            const particle = new FireworkParticle(this.firework.pos.x, this.firework.pos.y, false);
            this.particles.push(particle);
          }
        }
        
        done() {
          return this.exploded && this.particles.length === 0;
        }
        
        show() {
          if (!this.exploded) {
            this.firework.show(this.hue);
          }
          
          for (let particle of this.particles) {
            particle.show(this.hue);
          }
        }
      }
      
      class FireworkParticle {
        constructor(x, y, isFirework) {
          this.pos = p.createVector(x, y);
          this.isFirework = isFirework;
          this.lifespan = 255;
          
          if (isFirework) {
            // Moving upward
            this.vel = p.createVector(0, p.random(-12, -8));
          } else {
            // Explosion particle
            this.vel = p5.Vector.random2D();
            this.vel.mult(p.random(2, 10));
          }
          
          this.acc = p.createVector(0, 0);
        }
        
        applyForce(force) {
          this.acc.add(force);
        }
        
        update() {
          if (!this.isFirework) {
            this.vel.mult(0.95);
            this.lifespan -= 4;
          }
          
          this.vel.add(this.acc);
          this.pos.add(this.vel);
          this.acc.mult(0);
        }
        
        show(hue) {
          if (!this.isFirework) {
            p.strokeWeight(2);
            p.stroke(hue, 255, 255, this.lifespan);
          } else {
            p.strokeWeight(4);
            p.stroke(hue, 255, 255);
          }
          
          p.point(this.pos.x, this.pos.y);
        }
        
        isDead() {
          return this.lifespan < 0;
        }
      }
      
      // Bubbles animation
      function drawBubbles() {
        p.background(200, 50, 40, 25);
        
        // Handle existing bubbles
        for (let i = bubbles.length - 1; i >= 0; i--) {
          bubbles[i].update();
          bubbles[i].display();
          
          // Remove bubbles that have moved off screen
          if (bubbles[i].isOffScreen()) {
            bubbles.splice(i, 1);
          }
        }
        
        // Add new bubbles occasionally
        if (p.frameCount % 5 === 0 && bubbles.length < 100) {
          bubbles.push(new Bubble());
        }
      }
      
      class Bubble {
        constructor() {
          this.x = p.random(p.width);
          this.y = p.height + p.random(20, 50);
          this.size = p.random(10, 60);
          this.speed = p.map(this.size, 10, 60, 2.5, 0.8);
          this.hue = p.random(255);
          this.alpha = p.random(100, 200);
          this.wobble = p.random(0.1, 0.3);
          this.wobbleSpeed = p.random(0.01, 0.05);
          this.wobbleOffset = p.random(p.TWO_PI);
          this.highlighted = false;
        }
        
        update() {
          this.y -= this.speed;
          this.x += p.sin((p.frameCount * this.wobbleSpeed) + this.wobbleOffset) * this.wobble;
          
          // Check if mouse is close
          let d = p.dist(p.mouseX, p.mouseY, this.x, this.y);
          if (d < this.size/1.5) {
            this.highlighted = true;
            // Add slight repulsion from mouse
            let angle = p.atan2(this.y - p.mouseY, this.x - p.mouseX);
            this.x += p.cos(angle) * 1;
            this.y += p.sin(angle) * 1;
          } else {
            this.highlighted = false;
          }
        }
        
        display() {
          p.noFill();
          let strokeAlpha = this.highlighted ? 255 : this.alpha;
          let strokeWeight = this.highlighted ? 3 : 2;
          
          // Main bubble
          p.strokeWeight(strokeWeight);
          p.stroke(this.hue, 200, 255, strokeAlpha);
          p.ellipse(this.x, this.y, this.size);
          
          // Highlight
          p.strokeWeight(1);
          p.stroke(this.hue, 100, 255, strokeAlpha * 0.7);
          let highlightSize = this.size * 0.3;
          let highlightX = this.x - this.size * 0.2;
          let highlightY = this.y - this.size * 0.2;
          p.ellipse(highlightX, highlightY, highlightSize);
        }
        
        isOffScreen() {
          return this.y < -this.size;
        }
      }
      
      // Matrix Digital Rain animation
      function initMatrix() {
        symbols = [];
        streams = [];
        
        const symbolSize = 14;
        const columnsCount = p.floor(p.width / symbolSize);
        
        for (let i = 0; i < columnsCount; i++) {
          const stream = new Stream();
          stream.generateSymbols(i * symbolSize, p.random(-1000, 0));
          streams.push(stream);
        }
      }
      
      function drawMatrix() {
        p.background(0, 0, 0, 20);
        
        streams.forEach(stream => {
          stream.render();
        });
      }
      
      class Symbol {
        constructor(x, y, speed, first, opacity) {
          this.x = x;
          this.y = y;
          this.value = "";
          this.speed = speed;
          this.switchInterval = p.round(p.random(5, 20));
          this.first = first;
          this.opacity = opacity;
          this.setToRandomSymbol();
        }
        
        setToRandomSymbol() {
          if (p.frameCount % this.switchInterval === 0) {
            // Use a mix of katakana characters and latin alphanumerics
            if (p.random(1) > 0.5) {
              // Katakana Unicode range
              this.value = String.fromCharCode(0x30A0 + p.round(p.random(0, 96)));
            } else {
              // Latin alphanumeric and some symbols
              const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789$+-*/=%\"'#&_(),.;:?!|{}[]<>~^";
              this.value = chars.charAt(p.floor(p.random(chars.length)));
            }
          }
        }
        
        update() {
          this.y = (this.y >= p.height) ? 0 : this.y + this.speed;
          this.setToRandomSymbol();
        }
        
        render() {
          // First character in the stream is white and brighter
          if (this.first) {
            p.fill(180, 50, 255, this.opacity);
            p.textStyle(p.BOLD);
          } else {
            p.fill(120, 255, 200, this.opacity);
            p.textStyle(p.NORMAL);
          }
          
          p.textSize(14);
          p.textAlign(p.CENTER, p.CENTER);
          p.text(this.value, this.x, this.y);
        }
      }
      
      class Stream {
        constructor() {
          this.symbols = [];
          this.totalSymbols = p.round(p.random(5, 30));
          this.speed = p.random(4, 10);
        }
        
        generateSymbols(x, y) {
          // First symbol is white and brighter
          let opacity = p.random(150, 255);
          let first = true;
          
          for (let i = 0; i < this.totalSymbols; i++) {
            const symbol = new Symbol(
              x,
              y,
              this.speed,
              first,
              opacity
            );
            
            symbol.setToRandomSymbol();
            this.symbols.push(symbol);
            opacity -= p.random(5, 15);
            opacity = p.max(opacity, 0);
            y -= p.random(14, 20);
            first = false;
          }
        }
        
        render() {
          this.symbols.forEach(symbol => {
            symbol.render();
            symbol.update();
          });
        }
      }
      
      // Starfield animation
      function drawStarfield() {
        p.background(0, 0, 5);
        // Translate to center of screen
        p.translate(p.width / 2, p.height / 2);
        
        for (let i = 0; i < stars.length; i++) {
          stars[i].update();
          stars[i].show();
        }
      }
      
      class Star {
        constructor() {
          this.reset();
          // Start stars at random distances
          this.z = p.random(0, p.width * 2);
        }
        
        reset() {
          this.x = p.random(-p.width, p.width);
          this.y = p.random(-p.height, p.height);
          this.z = p.width * 2;
          this.pz = this.z;
          this.size = p.random(0.5, 2);
          this.color = p.color(p.random(150, 255), p.random(0, 50), 255);
        }
        
        update() {
          this.pz = this.z;
          this.z -= 5; // Speed of moving through space
          
          if (this.z < 1) {
            this.reset();
          }
        }
        
        show() {
          let sx = p.map(this.x / this.z, 0, 1, 0, p.width);
          let sy = p.map(this.y / this.z, 0, 1, 0, p.height);
          
          let px = p.map(this.x / this.pz, 0, 1, 0, p.width);
          let py = p.map(this.y / this.pz, 0, 1, 0, p.height);
          
          let r = p.map(this.z, 0, p.width * 2, this.size * 3, 0);
          
          p.fill(this.color);
          p.noStroke();
          p.ellipse(sx, sy, r, r);
          
          // Draw "motion streak"
          p.stroke(this.color);
          p.strokeWeight(r * 0.5);
          p.line(sx, sy, px, py);
        }
      }
      
      // Geometric animation
      function initGeometric() {
        shapes = [];
        
        // Create random geometric shapes
        for (let i = 0; i < 15; i++) {
          shapes.push({
            type: p.floor(p.random(3)), // 0: circle, 1: rectangle, 2: triangle
            x: p.random(p.width),
            y: p.random(p.height),
            size: p.random(20, 80),
            rotation: p.random(p.TWO_PI),
            rotationSpeed: p.random(-0.02, 0.02),
            xSpeed: p.random(-1, 1),
            ySpeed: p.random(-1, 1),
            hue: p.random(255),
            saturation: p.random(150, 255),
            brightness: p.random(200, 255),
            alpha: p.random(150, 200)
          });
        }
      }
      
      function drawGeometric() {
        p.background(0, 0, 20, 10);
        
        // Update time variable for sine/cosine calculations
        time += 0.01;
        
        for (let shape of shapes) {
          // Update position
          shape.x += shape.xSpeed;
          shape.y += shape.ySpeed;
          
          // Bounce off edges
          if (shape.x < 0 || shape.x > p.width) shape.xSpeed *= -1;
          if (shape.y < 0 || shape.y > p.height) shape.ySpeed *= -1;
          
          // Update rotation
          shape.rotation += shape.rotationSpeed;
          
          // Pulse size with sine wave
          const pulseSize = shape.size + p.sin(time + shape.x * 0.01) * 10;
          
          // Shift hue slowly
          shape.hue = (shape.hue + 0.2) % 255;
          
          p.push();
          p.translate(shape.x, shape.y);
          p.rotate(shape.rotation);
          
          // Set fill and stroke
          p.noStroke();
          p.fill(shape.hue, shape.saturation, shape.brightness, shape.alpha);
          
          // Draw shape based on type
          if (shape.type === 0) {
            // Circle
            p.ellipse(0, 0, pulseSize, pulseSize);
          } else if (shape.type === 1) {
            // Rectangle
            p.rectMode(p.CENTER);
            p.rect(0, 0, pulseSize, pulseSize * 0.7);
          } else if (shape.type === 2) {
            // Triangle
            const halfSize = pulseSize / 2;
            p.triangle(0, -halfSize, halfSize, halfSize, -halfSize, halfSize);
          }
          
          p.pop();
        }
        
        // Occasionally add a new shape
        if (p.frameCount % 100 === 0 && shapes.length < 25) {
          shapes.push({
            type: p.floor(p.random(3)),
            x: p.random(p.width),
            y: p.random(p.height),
            size: p.random(20, 80),
            rotation: p.random(p.TWO_PI),
            rotationSpeed: p.random(-0.02, 0.02),
            xSpeed: p.random(-1, 1),
            ySpeed: p.random(-1, 1),
            hue: p.random(255),
            saturation: p.random(150, 255),
            brightness: p.random(200, 255),
            alpha: p.random(150, 200)
          });
        }
      }
      
      // Flow Field animation
      function initFlowField() {
        // Create a flow field grid
        const resolution = 20;
        const cols = Math.ceil(p.width / resolution);
        const rows = Math.ceil(p.height / resolution);
        
        flowField = new Array(cols * rows);
        
        // Initialize with Perlin noise
        let yoff = 0;
        for (let y = 0; y < rows; y++) {
          let xoff = 0;
          for (let x = 0; x < cols; x++) {
            const index = x + y * cols;
            const angle = p.noise(xoff, yoff, time * 0.1) * p.TWO_PI * 2;
            const v = p5.Vector.fromAngle(angle);
            v.setMag(1);
            flowField[index] = v;
            xoff += 0.1;
          }
          yoff += 0.1;
        }
        
        // Create particles that will follow the flow field
        flowParticles = [];
        for (let i = 0; i < 1000; i++) {
          flowParticles.push({
            pos: p.createVector(p.random(p.width), p.random(p.height)),
            vel: p.createVector(0, 0),
            acc: p.createVector(0, 0),
            maxSpeed: p.random(2, 5),
            color: p.color(p.random(255), 200, 255, 50),
            prevPos: null,
            updatePrev: function() {
              this.prevPos = p.createVector(this.pos.x, this.pos.y);
            },
            applyForce: function(force) {
              this.acc.add(force);
            },
            update: function() {
              this.updatePrev();
              this.vel.add(this.acc);
              this.vel.limit(this.maxSpeed);
              this.pos.add(this.vel);
              this.acc.mult(0);
              
              // Wrap around edges
              if (this.pos.x > p.width) this.pos.x = 0;
              if (this.pos.x < 0) this.pos.x = p.width;
              if (this.pos.y > p.height) this.pos.y = 0;
              if (this.pos.y < 0) this.pos.y = p.height;
              
              // If crossing an edge, don't draw a line
              if (this.prevPos) {
                if (p.abs(this.pos.x - this.prevPos.x) > p.width/2 || 
                    p.abs(this.pos.y - this.prevPos.y) > p.height/2) {
                  this.updatePrev();
                }
              }
            },
            follow: function(flowField) {
              // Find grid position
              const resolution = 20;
              const x = Math.floor(this.pos.x / resolution);
              const y = Math.floor(this.pos.y / resolution);
              const index = x + y * Math.ceil(p.width / resolution);
              
              // Get flow force
              if (index >= 0 && index < flowField.length) {
                const force = flowField[index];
                this.applyForce(force);
              }
            },
            show: function() {
              p.stroke(this.color);
              p.strokeWeight(1);
              if (this.prevPos) {
                p.line(this.pos.x, this.pos.y, this.prevPos.x, this.prevPos.y);
              }
            }
          });
          
          // Initialize prevPos
          flowParticles[i].updatePrev();
        }
      }
      
      function createVortex(x, y) {
        const resolution = 20;
        const cols = Math.ceil(p.width / resolution);
        const vortexStrength = 0.5;
        
        // Update flow field with vortex influence
        for (let i = 0; i < flowField.length; i++) {
          const fieldX = (i % cols) * resolution;
          const fieldY = Math.floor(i / cols) * resolution;
          
          // Calculate angle from mouse to field point
          const dx = fieldX - x;
          const dy = fieldY - y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < 100) {
            // Create swirling vortex effect
            const angle = Math.atan2(dy, dx) + (Math.PI/2) * (1 - distance/100);
            const influence = p.map(distance, 0, 100, vortexStrength, 0);
            
            // Blend original flow with vortex
            const vortexVector = p5.Vector.fromAngle(angle);
            vortexVector.mult(influence);
            flowField[i].add(vortexVector);
            flowField[i].setMag(1); // Normalize
          }
        }
      }
      
      function drawFlowField() {
        p.background(0, 0, 10, 25);
        
        // Update flow field over time
        if (p.frameCount % 10 === 0) {
          time += 0.01;
          const resolution = 20;
          const cols = Math.ceil(p.width / resolution);
          const rows = Math.ceil(p.height / resolution);
          
          let yoff = time;
          for (let y = 0; y < rows; y++) {
            let xoff = time;
            for (let x = 0; x < cols; x++) {
              const index = x + y * cols;
              const angle = p.noise(xoff, yoff, time) * p.TWO_PI * 4;
              const v = p5.Vector.fromAngle(angle);
              v.setMag(1);
              flowField[index] = v;
              xoff += 0.1;
            }
            yoff += 0.1;
          }
        }
        
        // Show and update particles
        for (let particle of flowParticles) {
          particle.follow(flowField);
          particle.update();
          particle.show();
        }
        
        // Display instructions
        p.fill(255);
        p.noStroke();
        p.textAlign(p.CENTER);
        p.textSize(18);
        p.text("Drag mouse to create vortices", p.width/2, 30);
      }
      
      // Physics Playground animation
      function initPhysics() {
        physicsBodies = [];
        gravity = p.createVector(0, 0.2);
        
        // Create some initial bodies
        for (let i = 0; i < 10; i++) {
          createPhysicsBody(p.random(p.width), p.random(p.height/2));
        }
      }
      
      function createPhysicsBody(x, y) {
        const body = {
          position: p.createVector(x, y),
          velocity: p.createVector(p.random(-1, 1), p.random(-2, 0)),
          acceleration: p.createVector(0, 0),
          radius: p.random(10, 30),
          mass: 0,
          restitution: 0.8, // Bounciness
          color: p.color(p.random(255), 200, 255),
          
          applyForce: function(force) {
            // F = ma, so a = F/m
            let f = p5.Vector.div(force, this.mass);
            this.acceleration.add(f);
          },
          
          update: function() {
            this.velocity.add(this.acceleration);
            this.position.add(this.velocity);
            this.acceleration.mult(0);
            
            // Check boundaries
            if (this.position.x > p.width - this.radius) {
              this.position.x = p.width - this.radius;
              this.velocity.x *= -this.restitution;
            }
            if (this.position.x < this.radius) {
              this.position.x = this.radius;
              this.velocity.x *= -this.restitution;
            }
            if (this.position.y > p.height - this.radius) {
              this.position.y = p.height - this.radius;
              this.velocity.y *= -this.restitution;
              // Add friction when on ground
              this.velocity.x *= 0.99;
            }
            if (this.position.y < this.radius) {
              this.position.y = this.radius;
              this.velocity.y *= -this.restitution;
            }
          },
          
          checkCollision: function(other) {
            // Simple circle-circle collision detection
            const d = p.dist(this.position.x, this.position.y, other.position.x, other.position.y);
            if (d < this.radius + other.radius) {
              // Calculate collision response
              const angle = Math.atan2(other.position.y - this.position.y, other.position.x - this.position.x);
              const targetX = this.position.x + Math.cos(angle) * (this.radius + other.radius);
              const targetY = this.position.y + Math.sin(angle) * (this.radius + other.radius);
              const ax = (targetX - other.position.x) * 0.05;
              const ay = (targetY - other.position.y) * 0.05;
              
              this.velocity.x -= ax * other.mass / this.mass;
              this.velocity.y -= ay * other.mass / this.mass;
              other.velocity.x += ax * this.mass / other.mass;
              other.velocity.y += ay * this.mass / other.mass;
              
              // Add a little damping to the collision
              this.velocity.mult(0.99);
              other.velocity.mult(0.99);
            }
          },
          
          display: function() {
            p.noStroke();
            p.fill(this.color);
            p.ellipse(this.position.x, this.position.y, this.radius * 2);
            
            // Add a highlight
            p.fill(255, 50);
            p.ellipse(this.position.x - this.radius * 0.3, this.position.y - this.radius * 0.3, this.radius * 0.8);
          }
        };
        
        // Set mass based on radius (volume)
        body.mass = body.radius * body.radius * p.PI;
        
        physicsBodies.push(body);
        
        // Remove old bodies if we have too many
        if (physicsBodies.length > 30) {
          physicsBodies.shift();
        }
      }
      
      function drawPhysics() {
        p.background(230, 30, 20);
        
        // Draw ground
        p.noStroke();
        p.fill(200, 30, 100);
        p.rect(0, p.height - 20, p.width, 20);
        
        // Update physics bodies
        for (let i = 0; i < physicsBodies.length; i++) {
          // Apply gravity
          const gravityForce = p5.Vector.mult(gravity, physicsBodies[i].mass);
          physicsBodies[i].applyForce(gravityForce);
          
          // Check collisions with other bodies
          for (let j = i + 1; j < physicsBodies.length; j++) {
            physicsBodies[i].checkCollision(physicsBodies[j]);
          }
          
          physicsBodies[i].update();
          physicsBodies[i].display();
        }
        
        // Display instructions
        p.fill(255);
        p.noStroke();
        p.textAlign(p.CENTER);
        p.textSize(18);
        p.text("Click to add physics objects", p.width/2, 30);
      }
      
      // Audio Visualization animation
      function initAudio() {
        audioWaves = [];
        audioLevel = 0;
      }
      
      function createAudioPulse(x, y) {
        // Create a new expanding wave
        audioWaves.push({
          x: x,
          y: y,
          radius: 0,
          maxRadius: p.random(100, 300),
          speed: p.random(2, 5),
          color: p.color(p.random(255), 200, 255, 100),
          lineWeight: p.random(2, 6)
        });
        
        // Boost audio level
        audioLevel = 1;
      }
      
      function drawAudio() {
        p.background(0, 0, 20);
        
        // Calculate the beat visualization
        if (audioLevel > 0) {
          audioLevel *= 0.95; // Decay
        }
        
        // Draw center audio visualizer
        const centerX = p.width / 2;
        const centerY = p.height / 2;
        const baseBars = 128;
        const barWidth = (p.TWO_PI) / baseBars;
        
        for (let i = 0; i < baseBars; i++) {
          const angle = i * barWidth;
          
          // Calculate bar height using sin and audioLevel
          const barHeight = 50 + Math.sin(angle * 8 + time) * 20 * (1 + audioLevel * 2);
          const barHeight2 = 100 + Math.sin(angle * 4 + time * 2) * 30 * (1 + audioLevel);
          
          // Get coordinates for the bars
          const x1 = centerX + Math.cos(angle) * 30;
          const y1 = centerY + Math.sin(angle) * 30;
          const x2 = centerX + Math.cos(angle) * barHeight;
          const y2 = centerY + Math.sin(angle) * barHeight;
          const x3 = centerX + Math.cos(angle) * barHeight2;
          const y3 = centerY + Math.sin(angle) * barHeight2;
          
          // Draw inner bar (more white)
          p.strokeWeight(2);
          p.stroke(time * 10 % 255, 150, 255, 200 * (1 - audioLevel) + 50);
          p.line(x1, y1, x2, y2);
          
          // Draw outer bar (more colorful)
          p.strokeWeight(1);
          p.stroke((time * 5 + i) % 255, 200, 255, 150 * audioLevel + 50);
          p.line(x2, y2, x3, y3);
        }
        
        // Draw frequency circles
        p.noFill();
        for (let j = 0; j < 3; j++) {
          const radius = 150 + j * 30 + audioLevel * 20;
          p.strokeWeight(2 + audioLevel * 3);
          p.stroke((time * 20 + j * 60) % 255, 200, 255, 100);
          p.ellipse(centerX, centerY, radius * 2);
        }
        
        // Update and draw audio waves
        for (let i = audioWaves.length - 1; i >= 0; i--) {
          const wave = audioWaves[i];
          
          // Update
          wave.radius += wave.speed;
          
          // Draw
          p.noFill();
          p.strokeWeight(wave.lineWeight);
          p.stroke(wave.color);
          p.ellipse(wave.x, wave.y, wave.radius * 2);
          
          // Remove if too large
          if (wave.radius > wave.maxRadius) {
            audioWaves.splice(i, 1);
          }
        }
        
        // Increment time
        time += 0.05;
        
        // Display instructions
        p.fill(255);
        p.noStroke();
        p.textAlign(p.CENTER);
        p.textSize(18);
        p.text("Click anywhere to create sound waves", p.width/2, 30);
      }
      
      // Neural Network animation
      function initNeuralNetwork() {
        neurons = [];
        connections = [];
        neuralLayerRanges = [];
        neuralTrainingSamples = [];
        neuralPredictionPath = [];
        neuralTrainingLoss = null;
        neuralAutoProgress = 0;
        
        const layerSpacing = p.width / (neuralArchitecture.length + 1);
        const usableHeight = p.height * 0.7;
        const yOffset = (p.height - usableHeight) / 2;
        let neuronId = 0;
        let cumulativeIndex = 0;
        
        // Create neurons layer by layer
        for (let layerIndex = 0; layerIndex < neuralArchitecture.length; layerIndex++) {
          const layerSize = neuralArchitecture[layerIndex];
          neuralLayerRanges[layerIndex] = { start: cumulativeIndex, size: layerSize };
          
          const x = layerSpacing * (layerIndex + 1);
          
          for (let i = 0; i < layerSize; i++) {
            const normalizedPosition = layerSize === 1 ? 0.5 : i / (layerSize - 1);
            const y = yOffset + normalizedPosition * usableHeight;
            
            const neuron = {
              id: neuronId++,
              x,
              y,
              layer: layerIndex,
              indexInLayer: i,
              activation: 0,
              bias: p.random(-0.5, 0.5),
              displayRadius: 15,
              targetRadius: 15,
              incoming: [],
              outgoing: []
            };
            
            neurons.push(neuron);
          }
          
          cumulativeIndex += layerSize;
        }
        
        // Create connections between adjacent layers
        for (let layer = 0; layer < neuralArchitecture.length - 1; layer++) {
          const sourceMeta = neuralLayerRanges[layer];
          const targetMeta = neuralLayerRanges[layer + 1];
          
          for (let i = 0; i < sourceMeta.size; i++) {
            const sourceNeuron = neurons[sourceMeta.start + i];
            
            for (let j = 0; j < targetMeta.size; j++) {
              const targetNeuron = neurons[targetMeta.start + j];
              const connection = {
                source: sourceNeuron,
                target: targetNeuron,
                sourceIndex: i,
                targetIndex: j,
                layerIndex: layer,
                weight: p.random(-1, 1),
                signal: 0,
                animatedSignal: 0
              };
              
              connections.push(connection);
              sourceNeuron.outgoing.push(connection);
              targetNeuron.incoming.push(connection);
            }
          }
        }
      }
      
      function sigmoid(x) {
        return 1 / (1 + Math.exp(-x));
      }
      
      function forwardPropagate() {
        const safeWidth = Math.max(p.width, 1);
        const safeHeight = Math.max(p.height, 1);
        const t = (p.frameCount * 0.01) % p.TWO_PI;
        
        // Normalize mouse inputs to keep activations stable
        const mouseXNorm = p.constrain(p.mouseX / safeWidth, 0, 1);
        const mouseYNorm = p.constrain(p.mouseY / safeHeight, 0, 1);
        const timeSignal = sigmoid(Math.sin(t) * 2);
        
        neurons[0].activation = mouseXNorm;
        neurons[1].activation = mouseYNorm;
        neurons[2].activation = timeSignal;
        
        // Propagate activations forward layer by layer
        for (let layer = 1; layer < neuralArchitecture.length; layer++) {
          const { start, size } = neuralLayerRanges[layer];
          
          for (let i = 0; i < size; i++) {
            const neuron = neurons[start + i];
            let sum = neuron.bias;
            
            for (const connection of neuron.incoming) {
              const signal = connection.source.activation * connection.weight;
              sum += signal;
              connection.signal = Math.min(Math.abs(signal), 1.2);
            }
            
            neuron.activation = sigmoid(sum);
          }
        }
        
        // Smooth radius animation for nicer visuals
        for (let neuron of neurons) {
          neuron.targetRadius = 15 + neuron.activation * 20;
          neuron.displayRadius = p.lerp(neuron.displayRadius, neuron.targetRadius, 0.15);
        }
        
        for (let connection of connections) {
          connection.animatedSignal = p.lerp(connection.animatedSignal, connection.signal || 0, 0.2);
        }
        
        neuralAutoProgress = (neuralAutoProgress + 0.0025) % 1;
      }
      
      function drawNeuralNetwork() {
        p.background(10, 10, 20);
        forwardPropagate();
        
        // Draw recorded path
        if (trainingData.length > 1) {
          p.noFill();
          p.stroke(180, 255, 255, 40);
          p.strokeWeight(2);
          p.beginShape();
          const step = Math.max(1, Math.floor(trainingData.length / 250));
          for (let i = 0; i < trainingData.length; i += step) {
            p.vertex(trainingData[i].x, trainingData[i].y);
          }
          p.endShape();
        }
        
        // Draw learned prediction path
        if (neuralPredictionPath.length) {
          p.noFill();
          p.stroke(50, 255, 160, 90);
          p.strokeWeight(1.5);
          p.beginShape();
          for (const point of neuralPredictionPath) {
            p.vertex(point.predictedX * p.width, point.predictedY * p.height);
          }
          p.endShape();
          
          p.stroke(200, 80, 255, 35);
          p.beginShape();
          for (const point of neuralPredictionPath) {
            p.vertex(point.targetX * p.width, point.targetY * p.height);
          }
          p.endShape();
          
          if (neuralPredictionPath.length > 1) {
            const playbackIndex = Math.floor(neuralAutoProgress * (neuralPredictionPath.length - 1));
            const playbackPoint = neuralPredictionPath[playbackIndex];
            if (playbackPoint) {
              const px = playbackPoint.predictedX * p.width;
              const py = playbackPoint.predictedY * p.height;
              
              p.noStroke();
              p.fill(50, 255, 160, 220);
              p.ellipse(px, py, 10, 10);
              
              p.noFill();
              p.stroke(50, 255, 160, 120);
              p.strokeWeight(1.5);
              p.ellipse(px, py, 22, 22);
            }
          }
        }
        
        // Connections
        for (let connection of connections) {
          const signal = connection.animatedSignal || 0;
          const opacity = 25 + signal * 200;
          const strokeW = 0.5 + signal * 3.5;
          
          if (connection.weight > 0) {
            p.stroke(90, 220, 120, opacity);
          } else {
            p.stroke(0, 180, 255, opacity);
          }
          
          p.strokeWeight(strokeW);
          p.line(connection.source.x, connection.source.y, connection.target.x, connection.target.y);
        }
        
        // Neurons
        for (let neuron of neurons) {
          const glowSize = neuron.displayRadius + 10;
          const glowAlpha = neuron.activation * 60;
          
          p.noStroke();
          if (neuron.layer === 0) {
            p.fill(0, 200, 255, glowAlpha);
          } else if (neuron.layer === neuralArchitecture.length - 1) {
            p.fill(255, 200, 0, glowAlpha);
          } else {
            p.fill(200, 100, 255, glowAlpha);
          }
          p.ellipse(neuron.x, neuron.y, glowSize * 2);
          
          p.strokeWeight(2);
          p.stroke(255, 200);
          if (neuron.layer === 0) {
            p.fill(0, 140, 200);
          } else if (neuron.layer === neuralArchitecture.length - 1) {
            p.fill(200, 150, 0);
          } else {
            p.fill(150, 50, 200);
          }
          p.ellipse(neuron.x, neuron.y, neuron.displayRadius * 2);
          
          p.noStroke();
          p.fill(255, 255, 255, 180);
          p.ellipse(neuron.x, neuron.y, neuron.displayRadius * neuron.activation);
          
          p.fill(255);
          p.textAlign(p.CENTER, p.CENTER);
          p.textSize(9);
          p.text(neuron.activation.toFixed(2), neuron.x, neuron.y);
        }
        
        // Draw markers for predicted vs actual cursor
        const outputMeta = neuralLayerRanges[neuralLayerRanges.length - 1];
        const outputStart = outputMeta.start;
        const predictedX = neurons[outputStart].activation * p.width;
        const predictedY = neurons[outputStart + 1].activation * p.height;
        
        p.noFill();
        p.stroke(45, 255, 200, 150);
        p.strokeWeight(2);
        p.ellipse(predictedX, predictedY, 24, 24);
        p.noStroke();
        p.fill(45, 255, 200, 180);
        p.ellipse(predictedX, predictedY, 10, 10);
        
        if (p.mouseX >= 0 && p.mouseX <= p.width && p.mouseY >= 0 && p.mouseY <= p.height) {
          p.noFill();
          p.stroke(200, 80, 255, 130);
          p.strokeWeight(1.5);
          p.ellipse(p.mouseX, p.mouseY, 18, 18);
        }
        
        // Layer labels
        p.fill(255, 200);
        p.textAlign(p.CENTER);
        p.textSize(14);
        const layerNames = ['INPUT', 'HIDDEN 1', 'HIDDEN 2', 'OUTPUT'];
        for (let layer = 0; layer < neuralArchitecture.length; layer++) {
          const meta = neuralLayerRanges[layer];
          p.text(layerNames[layer] || `L${layer + 1}`, neurons[meta.start].x, 30);
        }
        
        // HUD
        p.textAlign(p.LEFT);
        p.textSize(12);
        p.fill(0, 200, 255);
        p.text(`Input X (mouse): ${neurons[0].activation.toFixed(2)}`, 20, p.height - 110);
        p.text(`Input Y (mouse): ${neurons[1].activation.toFixed(2)}`, 20, p.height - 90);
        p.text(`Input T (time): ${neurons[2].activation.toFixed(2)}`, 20, p.height - 70);
        p.text(`Samples recorded: ${trainingData.length}`, 20, p.height - 50);
        if (neuralTrainingSamples.length) {
          p.text(`Samples learned: ${neuralTrainingSamples.length}`, 20, p.height - 30);
        }
        
        p.fill(255, 200, 0);
        p.textAlign(p.RIGHT);
        p.text(`Output X (prediction): ${neurons[outputStart].activation.toFixed(2)}`, p.width - 20, p.height - 110);
        p.text(`Output Y (prediction): ${neurons[outputStart + 1].activation.toFixed(2)}`, p.width - 20, p.height - 90);
        p.text(`Training loss: ${neuralTrainingLoss !== null ? neuralTrainingLoss.toFixed(4) : '‚Äî'}`, p.width - 20, p.height - 70);
        if (neuralPredictionPath.length) {
          p.text(`Playback path: ${neuralPredictionPath.length} pts`, p.width - 20, p.height - 50);
        }
        
        p.fill(255);
        p.textAlign(p.CENTER);
        p.textSize(15);
        p.text("Click + drag to record a path, release to train the network", p.width / 2, p.height - 15);
      }
      
      function trainNeuralNetwork(data) {
        if (data.length < 12) return;
        
        const samples = buildNeuralSamples(data);
        if (!samples.length) return;
        
        neuralTrainingSamples = samples;
        let latestLoss = null;
        const epochs = Math.min(60, 10 + samples.length);
        
        for (let epoch = 0; epoch < epochs; epoch++) {
          const shuffled = p.shuffle(samples.slice());
          let epochLoss = 0;
          
          for (const sample of shuffled) {
            const activations = runForwardSample(sample.inputs);
            const deltas = computeBackpropDeltas(activations, sample.targets);
            applyGradients(activations, deltas, NEURAL_LEARNING_RATE);
            epochLoss += meanSquaredError(activations[activations.length - 1], sample.targets);
          }
          
          latestLoss = epochLoss / shuffled.length;
        }
        
        neuralTrainingLoss = latestLoss;
        neuralPredictionPath = generateNeuralPredictionPath(samples);
        
        // Visual feedback
        for (let neuron of neurons) {
          neuron.targetRadius = 25;
        }
      }

      function buildNeuralSamples(data) {
        if (data.length < 6) return [];
        
        const samples = [];
        const safeWidth = Math.max(p.width, 1);
        const safeHeight = Math.max(p.height, 1);
        const maxSamples = 250;
        const stride = Math.max(1, Math.floor(data.length / maxSamples));
        const denom = Math.max(1, data.length - 1);
        
        for (let i = 0; i < data.length - 1; i += stride) {
          const current = data[i];
          const next = data[Math.min(i + stride, data.length - 1)];
          const progress = i / denom;
          
          samples.push({
            inputs: [
              p.constrain(current.x / safeWidth, 0, 1),
              p.constrain(current.y / safeHeight, 0, 1),
              progress
            ],
            targets: [
              p.constrain(next.x / safeWidth, 0, 1),
              p.constrain(next.y / safeHeight, 0, 1)
            ]
          });
        }
        
        return samples;
      }
      
      function runForwardSample(inputValues) {
        const activations = [];
        activations[0] = inputValues.slice();
        
        for (let layer = 1; layer < neuralArchitecture.length; layer++) {
          const prevActivations = activations[layer - 1];
          const current = [];
          const { start, size } = neuralLayerRanges[layer];
          
          for (let i = 0; i < size; i++) {
            const neuron = neurons[start + i];
            let sum = neuron.bias;
            
            for (const connection of neuron.incoming) {
              const sourceIndex = connection.source.indexInLayer;
              sum += prevActivations[sourceIndex] * connection.weight;
            }
            
            current[i] = sigmoid(sum);
          }
          
          activations[layer] = current;
        }
        
        return activations;
      }
      
      function computeBackpropDeltas(activations, targetValues) {
        const deltas = new Array(neuralArchitecture.length);
        const outputLayerIndex = neuralArchitecture.length - 1;
        const outputActivations = activations[outputLayerIndex];
        const outputDeltas = new Array(outputActivations.length);
        
        for (let i = 0; i < outputActivations.length; i++) {
          const error = outputActivations[i] - targetValues[i];
          outputDeltas[i] = error * sigmoidDerivativeFromActivation(outputActivations[i]);
        }
        deltas[outputLayerIndex] = outputDeltas;
        
        for (let layer = outputLayerIndex - 1; layer >= 1; layer--) {
          const layerActivations = activations[layer];
          const layerDeltas = new Array(layerActivations.length);
          
          for (let i = 0; i < layerActivations.length; i++) {
            const neuron = neurons[neuralLayerRanges[layer].start + i];
            let sum = 0;
            for (const connection of neuron.outgoing) {
              if (connection.target.layer !== layer + 1) continue;
              const targetIndex = connection.target.indexInLayer;
              sum += connection.weight * deltas[layer + 1][targetIndex];
            }
            layerDeltas[i] = sum * sigmoidDerivativeFromActivation(layerActivations[i]);
          }
          
          deltas[layer] = layerDeltas;
        }
        
        return deltas;
      }
      
      function applyGradients(activations, deltas, learningRate) {
        for (let layer = 0; layer < neuralArchitecture.length - 1; layer++) {
          const sourceActivations = activations[layer];
          const targetDeltas = deltas[layer + 1];
          const targetMeta = neuralLayerRanges[layer + 1];
          
          for (let i = 0; i < targetMeta.size; i++) {
            const neuron = neurons[targetMeta.start + i];
            const delta = targetDeltas[i];
            neuron.bias -= learningRate * delta;
            
            for (const connection of neuron.incoming) {
              if (connection.source.layer !== layer) continue;
              const gradient = sourceActivations[connection.source.indexInLayer] * delta;
              connection.weight -= learningRate * gradient;
              connection.weight = p.constrain(connection.weight, -MAX_NEURAL_WEIGHT, MAX_NEURAL_WEIGHT);
            }
          }
        }
      }
      
      function sigmoidDerivativeFromActivation(activation) {
        return activation * (1 - activation);
      }
      
      function meanSquaredError(outputActivations, targets) {
        let sum = 0;
        for (let i = 0; i < targets.length; i++) {
          const diff = outputActivations[i] - targets[i];
          sum += diff * diff;
        }
        return sum / targets.length;
      }
      
      function generateNeuralPredictionPath(samples, maxPoints = 90) {
        if (!samples.length) return [];
        const preview = [];
        const stride = Math.max(1, Math.floor(samples.length / maxPoints));
        
        for (let i = 0; i < samples.length; i += stride) {
          const sample = samples[i];
          const activations = runForwardSample(sample.inputs);
          const outputs = activations[activations.length - 1];
          
          preview.push({
            targetX: sample.targets[0],
            targetY: sample.targets[1],
            predictedX: outputs[0],
            predictedY: outputs[1]
          });
        }
        
        return preview;
      }
      
      // Kaleidoscope animation
      function initKaleidoscope() {
        angle = p.TWO_PI / symmetry;
        p.background(0, 0, 10);
      }
      
      function drawKaleidoscope() {
        // Only draw when mouse is pressed
        if (p.mouseIsPressed) {
          p.translate(p.width / 2, p.height / 2);

          for (let i = 0; i < symmetry; i++) {
            p.rotate(angle);
            
            // Draw line with changing color
            kaleidoscopeHue = (kaleidoscopeHue + 0.5) % 255;
            p.stroke(kaleidoscopeHue, 200, 255, 200);
            p.strokeWeight(kaleidoscopeBrushSize);
            
            const mx = p.mouseX - p.width / 2;
            const my = p.mouseY - p.height / 2;
            const pmx = p.pmouseX - p.width / 2;
            const pmy = p.pmouseY - p.height / 2;
            
            p.line(mx, my, pmx, pmy);
            
            // Mirrored line
            p.push();
            p.scale(1, -1);
            p.line(mx, my, pmx, pmy);
            p.pop();
          }
        }
      }

      // 3D Terrain animation
      function initTerrain() {
        cols = Math.floor(w / scl);
        rows = Math.floor(h / scl);
        terrain = new Array(cols).fill(0).map(() => new Array(rows).fill(0));
      }

      function drawTerrain() {
        flying -= 0.05;
        let yoff = flying;
        for (let y = 0; y < rows; y++) {
          let xoff = 0;
          for (let x = 0; x < cols; x++) {
            terrain[x][y] = p.map(p.noise(xoff, yoff), 0, 1, -100, 100);
            xoff += 0.1;
          }
          yoff += 0.1;
        }

        p.background(0, 0, 15);
        p.stroke(150, 150, 255, 50);
        p.noFill();

        // Camera control
        let camX = p.map(p.mouseX, 0, p.width, -200, 200);
        let camY = p.map(p.mouseY, 0, p.height, -200, 200);
        p.camera(camX, camY + 200, 500, 0, 0, 0, 0, 1, 0);

        p.rotateX(p.PI / 3);
        p.translate(-w / 2, -h / 2);

        for (let y = 0; y < rows - 1; y++) {
          p.beginShape(p.TRIANGLE_STRIP);
          for (let x = 0; x < cols; x++) {
            // Color based on height
            const h1 = terrain[x][y];
            const h2 = terrain[x][y+1];
            p.fill(p.map(h1, -100, 100, 120, 220), 200, 255);
            p.vertex(x * scl, y * scl, h1);
            p.fill(p.map(h2, -100, 100, 120, 220), 200, 255);
            p.vertex(x * scl, (y + 1) * scl, h2);
          }
          p.endShape();
        }
      }

      // Cloth Simulation
      class ClothPoint {
        constructor(x, y) {
          this.pos = p.createVector(x, y);
          this.prevPos = p.createVector(x, y);
          this.acc = p.createVector(0, 0);
          this.isPinned = false;
        }
        
        applyForce(force) {
          this.acc.add(force);
        }

        update(deltaTime) {
          if (this.isPinned) return;
          
          let vel = p5.Vector.sub(this.pos, this.prevPos);
          vel.mult(0.99); // Damping
          
          this.prevPos.set(this.pos);
          
          let nextPos = p5.Vector.add(this.pos, vel);
          nextPos.add(p5.Vector.mult(this.acc, deltaTime * deltaTime));
          this.pos.set(nextPos);
          
          this.acc.mult(0);
        }

        display() {
          p.stroke(255);
          p.strokeWeight(this.isPinned ? 8 : 4);
          p.point(this.pos.x, this.pos.y);
        }
      }
      
      class ClothStick {
        constructor(p1, p2) {
          this.p1 = p1;
          this.p2 = p2;
          this.length = p.dist(p1.pos.x, p1.pos.y, p2.pos.x, p2.pos.y);
        }
        
        update() {
          const diff = p5.Vector.sub(this.p2.pos, this.p1.pos);
          const dist = diff.mag();
          const diffFactor = (this.length - dist) / dist;
          const offset = p5.Vector.mult(diff, diffFactor * 0.5);

          if (!this.p1.isPinned) this.p1.pos.sub(offset);
          if (!this.p2.isPinned) this.p2.pos.add(offset);
        }
        
        isNearMouse(mx, my, pmx, pmy) {
          // Check if mouse line segment intersects this stick
          const d1 = p.dist(mx, my, this.p1.pos.x, this.p1.pos.y);
          const d2 = p.dist(mx, my, this.p2.pos.x, this.p2.pos.y);
          return (d1 + d2 >= this.length - 1 && d1 + d2 <= this.length + 1);
        }

        display() {
          p.stroke(255, 100);
          p.strokeWeight(1);
          p.line(this.p1.pos.x, this.p1.pos.y, this.p2.pos.x, this.p2.pos.y);
        }
      }

      function initCloth() {
        clothPoints = [];
        clothSticks = [];
        clothGravity = p.createVector(0, 0.5);
        
        const cols = 35;
        const rows = 20;
        const spacing = 15;
        const startX = p.width / 2 - (cols * spacing) / 2;

        for (let y = 0; y <= rows; y++) {
          for (let x = 0; x <= cols; x++) {
            const point = new ClothPoint(startX + x * spacing, 50 + y * spacing);
            if (y === 0) { // Pin top row
              point.isPinned = true;
            }
            clothPoints.push(point);

            // Add horizontal stick
            if (x > 0) {
              clothSticks.push(new ClothStick(clothPoints[clothPoints.length - 2], point));
            }
            // Add vertical stick
            if (y > 0) {
              clothSticks.push(new ClothStick(clothPoints[clothPoints.length - (cols + 2)], point));
            }
          }
        }
      }
      
      function drawCloth() {
        p.background(0, 0, 20);

        // Update physics
        for (let point of clothPoints) {
          point.applyForce(clothGravity);
          point.update(0.5);
        }

        // Constraint satisfaction loops
        for (let i = 0; i < 5; i++) {
          for (let stick of clothSticks) {
            stick.update();
          }
        }

        // Display
        for (let stick of clothSticks) {
          stick.display();
        }
      }

    };
    
    // Randomly select an animation on page load
    document.addEventListener('DOMContentLoaded', function() {
      const animations = ['particles', 'waves', 'flocking', 'fireworks', 'bubbles', 'matrix', 'starfield', 'geometric', 'flow', 'physics', 'audio', 'neural', 'kaleidoscope', 'terrain', 'cloth'];
      const randomAnimation = animations[Math.floor(Math.random() * animations.length)];
      switchAnimation(randomAnimation);
    });
  </script>
  
  <!-- Mixpanel Analytics -->
  <script type="text/javascript">
  (function(f,b){if(!b.__SV){var e,g,i,h;window.mixpanel=b;b._i=[];b.init=function(e,f,c){function g(a,d){var b=d.split(".");2==b.length&&(a=a[b[0]],d=b[1]);a[d]=function(){a.push([d].concat(Array.prototype.slice.call(arguments,0)))}}var a=b;for(void 0!==c?a=b[c]=[]:c="mixpanel",a.people=a.people||[],a.toString=function(a){var d="mixpanel";"mixpanel"!==c&&(d+="."+c);a||(d+=" (stub)");return d},a.people.toString=function(){return a.toString(1)+".people (stub)"},i="disable time_event track track_pageview track_links track_forms track_with_groups add_group set_group remove_group register register_once alias unregister identify name_tag set_config reset opt_in_tracking opt_out_tracking has_opted_in_tracking has_opted_out_tracking clear_opt_in_out_tracking start_batch_senders people.set people.set_once people.unset people.increment people.append people.union people.track_charge people.clear_charges people.delete_user people.remove".split(" "),h=0;h<i.length;h++)g(a,i[h]);var j="set set_once union unset remove delete".split(" ");a.get_group=function(){function b(c){d[c]=function(){call2_args=arguments;call2=[c].concat(Array.prototype.slice.call(call2_args,0));a.push([e,call2])}}for(var d={},e=["get_group"].concat(Array.prototype.slice.call(arguments,0)),c=0;c<j.length;c++)b(j[c]);return d};b._i.push([e,f,c])};b.__SV=1.2;e=f.createElement("script");e.type="text/javascript";e.async=!0;e.src="undefined"!==typeof MIXPANEL_CUSTOM_LIB_URL?MIXPANEL_CUSTOM_LIB_URL:"file:"===f.location.protocol&&"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js".match(/^\/\//)?"https://cdn.mxpnl.com/libs/mixpanel-2-latest.min.js":"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js";g=f.getElementsByTagName("script")[0];g.parentNode.insertBefore(e,g)}})(document,window.mixpanel||[]);
  </script>
  
  <!-- Mixpanel Configuration -->
  <script>
    // You can override these values by setting them before loading mixpanel-config.js
    window.MIXPANEL_TOKEN = 'YOUR_MIXPANEL_TOKEN_HERE'; // Replace with your actual token
    window.MIXPANEL_ENABLED = true; // Set to false to disable tracking
  </script>
  <script src="/javascript/mixpanel-config.js"></script>
  
  <script>
    // Track animation switches
    function trackAnimationSwitch(animationType, previousAnimation) {
      window.trackEvent('Animation Switched', {
        animation_type: animationType,
        previous_animation: previousAnimation || currentAnimationType || 'none'
      });
    }
    
    // Override the switchAnimation function to add tracking
    const originalSwitchAnimation = window.switchAnimation;
    window.switchAnimation = function(type) {
      const previous = currentAnimationType;
      trackAnimationSwitch(type, previous);
      return originalSwitchAnimation(type);
    };
  </script>
</body>
</html> 